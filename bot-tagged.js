const { Client, GatewayIntentBits, Events, EmbedBuilder, PermissionsBitField, Partials, ChannelType, ThreadAutoArchiveDuration, ButtonBuilder, ButtonStyle, ActionRowBuilder, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, SlashCommandBuilder } = require('discord.js');
const fs = require('fs').promises;
const path = require('path');

// ================================================
// üåç CONFIGURA√á√ïES VIA VARI√ÅVEIS DE AMBIENTE
// ================================================

const PIX_CONFIG = {
    chave: process.env.PIX_CHAVE || 'seuemail@gmail.com',
    nome: process.env.PIX_NOME || 'Seu Nome Completo',
    banco: process.env.PIX_BANCO || 'Nubank'
};

const CANAIS_SERVICOS = process.env.CANAIS_SERVICOS ? 
    process.env.CANAIS_SERVICOS.split(',').map(c => c.trim()) : 
    ['servi√ßos'];

const CANAL_LOG_FINALIZADOS = process.env.CANAL_LOG_FINALIZADOS || 'servicos-finalizados';
const CARGO_ADMIN_PRINCIPAL = process.env.CARGO_ADMIN_PRINCIPAL || 'Hellza';

const CARGOS_SUPORTE = process.env.CARGOS_SUPORTE ? 
    process.env.CARGOS_SUPORTE.split(',').map(c => c.trim()) : 
    ['admin', 'administrador', 'mod', 'moderador', 'staff', 'suporte', 'vendas', 'atendimento'];

const CARGO_CLIENTE_COMPROU = process.env.CARGO_CLIENTE_COMPROU || 'J√° comprou';
const CARGO_SERVICO_EM_ANDAMENTO = process.env.CARGO_SERVICO_EM_ANDAMENTO || 'Servi√ßo em Andamento';

// üìÅ ARQUIVOS PARA SISTEMA MULTI-JOGOS
const JOGOS_FILE = './jogos_disponiveis.json';
const SERVICOS_FILE = './servicos_multi_jogos.json';

// üéÆ JOGOS INICIAIS (ser√° movido para JSON)
const jogosIniciais = {
    'zenless-zone-zero': {
        id: 'zenless-zone-zero',
        nome: 'Zenless Zone Zero',
        emoji: '‚ö°',
        descricao: 'Servi√ßos para Zenless Zone Zero - Orpheus/Evellyn',
        ativo: true,
        ordem: 1
    },
    'honkai-star-rail': {
        id: 'honkai-star-rail',
        nome: 'Honkai Star Rail',
        emoji: 'üåü',
        descricao: 'Servi√ßos para Honkai Star Rail',
        ativo: true,
        ordem: 2
    },
    'genshin-impact': {
        id: 'genshin-impact',
        nome: 'Genshin Impact',
        emoji: 'üó°Ô∏è',
        descricao: 'Servi√ßos para Genshin Impact',
        ativo: true,
        ordem: 3
    }
};

// üéÆ SERVI√áOS INICIAIS COM IDENTIFICA√á√ÉO DE JOGO
const servicosIniciais = {
    // ========== ZENLESS ZONE ZERO ==========
    'zzz-missao-completa': {
        id: 'zzz-missao-completa',
        jogo_id: 'zenless-zone-zero',
        nome: 'Miss√£o Principal COMPLETA',
        descricao: 'Temp. 1 e 2 COMPLETA [INCLUSO VERS√ÉO 2.2]',
        preco: parseFloat(process.env.SERVICO_ZZZ_MISSAO_COMPLETA_PRECO) || 90.00,
        tempo: '1-2 dias',
        emoji: '‚≠ê',
        destaque: true,
        ordem: 1
    },
    'zzz-todas-historias': {
        id: 'zzz-todas-historias',
        jogo_id: 'zenless-zone-zero',
        nome: 'TODAS Hist√≥rias de Agentes',
        descricao: 'TODAS as hist√≥rias de Agentes [14 Hist√≥rias completas]',
        preco: parseFloat(process.env.SERVICO_ZZZ_TODAS_HISTORIAS_PRECO) || 76.00,
        tempo: '1-3 dias',
        emoji: 'üë•',
        destaque: true,
        ordem: 2
    },
    'zzz-farm-mensal': {
        id: 'zzz-farm-mensal',
        jogo_id: 'zenless-zone-zero',
        nome: 'Farm Mensal',
        descricao: 'FARM MENSAL - Cuidado da conta',
        preco: parseFloat(process.env.SERVICO_ZZZ_FARM_MENSAL_PRECO) || 62.00,
        tempo: '30 dias',
        emoji: 'üìÜ',
        destaque: true,
        ordem: 3
    },
    'zzz-todos-eventos': {
        id: 'zzz-todos-eventos',
        jogo_id: 'zenless-zone-zero',
        nome: 'Todos os Eventos v2.2',
        descricao: 'TODOS os Eventos da atualiza√ß√£o mais recente [Vers√£o 2.2]',
        preco: parseFloat(process.env.SERVICO_ZZZ_TODOS_EVENTOS_PRECO) || 22.00,
        tempo: '3-5 horas',
        emoji: 'üéâ',
        destaque: true,
        ordem: 4
    },
    'zzz-investida-mortal': {
        id: 'zzz-investida-mortal',
        jogo_id: 'zenless-zone-zero',
        nome: 'Investida Mortal',
        descricao: 'INVESTIDA MORTAL - Endgame',
        preco: parseFloat(process.env.SERVICO_ZZZ_INVESTIDA_MORTAL_PRECO) || 14.00,
        tempo: '1-2 horas',
        emoji: '‚öîÔ∏è',
        destaque: true,
        ordem: 5
    },
    'zzz-nodulo-vermelho': {
        id: 'zzz-nodulo-vermelho',
        jogo_id: 'zenless-zone-zero',
        nome: 'N√≥dulo Vermelho',
        descricao: 'N√≥dulo Vermelho [1¬∞ ao 7¬∞ n√≠vel]',
        preco: parseFloat(process.env.SERVICO_ZZZ_NODULO_VERMELHO_PRECO) || 12.00,
        tempo: '1-1.5 horas',
        emoji: 'üî¥',
        destaque: true,
        ordem: 6
    },
    'zzz-missao-avulsa': {
        id: 'zzz-missao-avulsa',
        jogo_id: 'zenless-zone-zero',
        nome: 'Miss√£o Principal Avulsa',
        descricao: 'Apenas 1 Cap√≠tulo avulso da Miss√£o Principal',
        preco: parseFloat(process.env.SERVICO_ZZZ_MISSAO_AVULSA_PRECO) || 8.00,
        tempo: '2-4 horas',
        emoji: 'üìú',
        destaque: false,
        ordem: 10
    },
    'zzz-farm-diario': {
        id: 'zzz-farm-diario',
        jogo_id: 'zenless-zone-zero',
        nome: 'Farm Di√°rio',
        descricao: 'FARM DI√ÅRIO - Cuidado da conta',
        preco: parseFloat(process.env.SERVICO_ZZZ_FARM_DIARIO_PRECO) || 2.00,
        tempo: '30 min/dia',
        emoji: 'üìÖ',
        destaque: false,
        ordem: 15
    },

    // ========== HONKAI STAR RAIL ==========
    'hsr-historia-principal': {
        id: 'hsr-historia-principal',
        jogo_id: 'honkai-star-rail',
        nome: 'Hist√≥ria Principal Completa',
        descricao: 'Hist√≥ria principal completa de Honkai Star Rail',
        preco: parseFloat(process.env.SERVICO_HSR_HISTORIA_PRINCIPAL_PRECO) || 85.00,
        tempo: '1-2 dias',
        emoji: 'üìñ',
        destaque: true,
        ordem: 1
    },
    'hsr-farm-reliquia': {
        id: 'hsr-farm-reliquia',
        jogo_id: 'honkai-star-rail',
        nome: 'Farm de Rel√≠quias',
        descricao: 'Farm completo de rel√≠quias de alta qualidade',
        preco: parseFloat(process.env.SERVICO_HSR_FARM_RELIQUIA_PRECO) || 45.00,
        tempo: '3-5 horas',
        emoji: 'üíé',
        destaque: true,
        ordem: 2
    },
    'hsr-caverna-simulada': {
        id: 'hsr-caverna-simulada',
        jogo_id: 'honkai-star-rail',
        nome: 'Universo Simulado',
        descricao: 'Completo do Universo Simulado todas as dificuldades',
        preco: parseFloat(process.env.SERVICO_HSR_CAVERNA_SIMULADA_PRECO) || 25.00,
        tempo: '2-3 horas',
        emoji: 'üåå',
        destaque: true,
        ordem: 3
    },

    // ========== GENSHIN IMPACT ==========
    'gi-historia-archon': {
        id: 'gi-historia-archon',
        jogo_id: 'genshin-impact',
        nome: 'Hist√≥ria dos Archons Completa',
        descricao: 'Todas as hist√≥rias dos Archons dispon√≠veis',
        preco: parseFloat(process.env.SERVICO_GI_HISTORIA_ARCHON_PRECO) || 95.00,
        tempo: '2-3 dias',
        emoji: 'üëë',
        destaque: true,
        ordem: 1
    },
    'gi-farm-artefato': {
        id: 'gi-farm-artefato',
        jogo_id: 'genshin-impact',
        nome: 'Farm de Artefatos',
        descricao: 'Farm completo de artefatos 5 estrelas',
        preco: parseFloat(process.env.SERVICO_GI_FARM_ARTEFATO_PRECO) || 50.00,
        tempo: '4-6 horas',
        emoji: '‚ö±Ô∏è',
        destaque: true,
        ordem: 2
    },
    'gi-abismo-espiral': {
        id: 'gi-abismo-espiral',
        jogo_id: 'genshin-impact',
        nome: 'Abismo Espiral 36‚òÖ',
        descricao: 'Completo do Abismo Espiral com 36 estrelas',
        preco: parseFloat(process.env.SERVICO_GI_ABISMO_ESPIRAL_PRECO) || 35.00,
        tempo: '1-2 horas',
        emoji: '‚≠ê',
        destaque: true,
        ordem: 3
    }
};

// ================================================
// üîß CONFIGURA√á√ÉO DO BOT
// ================================================

const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMessageReactions,
        GatewayIntentBits.DirectMessages,
        GatewayIntentBits.GuildMembers
    ],
    partials: [Partials.Message, Partials.Channel, Partials.Reaction, Partials.User]
});

// üõí SISTEMA DE CONTROLE
const carrinhos = new Map();
const contadorThreads = new Map();
const threadsFinalizadas = new Map();
const threadsAtivas = new Map();
const mensagensOficiais = new Set();

// ================================================
// üíæ SISTEMA MULTI-JOGOS 100% DIN√ÇMICO
// ================================================

async function inicializarJogos() {
    try {
        const data = await fs.readFile(JOGOS_FILE, 'utf8');
        const jogosExistentes = JSON.parse(data);
        console.log(`üéÆ Arquivo de jogos encontrado: ${Object.keys(jogosExistentes).length} jogos`);
        return jogosExistentes;
    } catch (error) {
        console.log('üéÆ Criando arquivo inicial de jogos...');
        await salvarJogos(jogosIniciais);
        console.log(`‚úÖ Arquivo inicial de jogos criado: ${Object.keys(jogosIniciais).length} jogos`);
        return jogosIniciais;
    }
}

async function salvarJogos(jogos) {
    try {
        await fs.writeFile(JOGOS_FILE, JSON.stringify(jogos, null, 2), 'utf8');
        console.log('üíæ Jogos salvos com sucesso');
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao salvar jogos:', error);
        return false;
    }
}

async function inicializarServicos() {
    try {
        const data = await fs.readFile(SERVICOS_FILE, 'utf8');
        const servicosExistentes = JSON.parse(data);
        console.log(`üìÅ Arquivo de servi√ßos encontrado: ${Object.keys(servicosExistentes).length} servi√ßos`);
        return servicosExistentes;
    } catch (error) {
        console.log('üìù Criando arquivo inicial de servi√ßos...');
        await salvarServicos(servicosIniciais);
        console.log(`‚úÖ Arquivo inicial de servi√ßos criado: ${Object.keys(servicosIniciais).length} servi√ßos`);
        return servicosIniciais;
    }
}

async function salvarServicos(servicos) {
    try {
        await fs.writeFile(SERVICOS_FILE, JSON.stringify(servicos, null, 2), 'utf8');
        console.log('üíæ Servi√ßos salvos com sucesso');
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao salvar servi√ßos:', error);
        return false;
    }
}

async function obterTodosJogos() {
    return global.jogosDisponiveis || await inicializarJogos();
}

async function obterJogosAtivos() {
    const jogos = await obterTodosJogos();
    return Object.values(jogos)
        .filter(j => j.ativo === true)
        .sort((a, b) => (a.ordem || 999) - (b.ordem || 999));
}

async function obterTodosServicos() {
    return global.servicosCompletos || await inicializarServicos();
}

async function getServico(servicoId) {
    const servicos = await obterTodosServicos();
    return servicos[servicoId];
}

async function getJogo(jogoId) {
    const jogos = await obterTodosJogos();
    return jogos[jogoId];
}

async function obterServicosPorJogo(jogoId) {
    const servicos = await obterTodosServicos();
    return Object.values(servicos)
        .filter(s => s.jogo_id === jogoId)
        .sort((a, b) => (a.ordem || 999) - (b.ordem || 999));
}

async function obterServicosDestaquePorJogo(jogoId) {
    const servicos = await obterServicosPorJogo(jogoId);
    return servicos.filter(s => s.destaque === true).slice(0, 6);
}

// ================================================
// üîç FUN√á√ïES UTILIT√ÅRIAS (mantidas iguais)
// ================================================

function isHellzaAdmin(member) {
    if (!member || !member.roles || !member.roles.cache) return false;
    return member.roles.cache.some(role =>
        role.name.toLowerCase() === CARGO_ADMIN_PRINCIPAL.toLowerCase()
    );
}

function isSuporteAdmin(member) {
    if (!member || !member.roles || !member.roles.cache) return false;
    return member.roles.cache.some(role =>
        CARGOS_SUPORTE.some(cargo => role.name.toLowerCase().includes(cargo.toLowerCase()))
    );
}

function isQualquerAdmin(member) {
    if (!member) return false;
    return isHellzaAdmin(member) || isSuporteAdmin(member);
}

function isAdminNaGuild(userId, guild) {
    try {
        const member = guild.members.cache.get(userId);
        if (!member) return false;
        return isQualquerAdmin(member);
    } catch (error) {
        console.error(`‚ùå Erro ao verificar admin ${userId}:`, error);
        return false;
    }
}

function getProximoNumeroThread(userId) {
    if (!contadorThreads.has(userId)) {
        contadorThreads.set(userId, 1);
        return 1;
    } else {
        const novoNumero = contadorThreads.get(userId) + 1;
        contadorThreads.set(userId, novoNumero);
        return novoNumero;
    }
}

function isThreadFinalizada(threadId) {
    return threadsFinalizadas.has(threadId);
}

function finalizarThread(threadId, adminId) {
    threadsFinalizadas.set(threadId, {
        finalizada: true,
        adminResponsavel: adminId,
        dataFinalizacao: new Date().toISOString()
    });
}

function temThreadAtiva(userId) {
    return threadsAtivas.has(userId);
}

function getThreadAtiva(userId) {
    return threadsAtivas.get(userId);
}

function marcarThreadAtiva(userId, threadId) {
    threadsAtivas.set(userId, threadId);
    console.log(`üîí Thread ${threadId} marcada como ativa para ${userId}`);
}

function removerThreadAtiva(userId) {
    if (threadsAtivas.has(userId)) {
        threadsAtivas.delete(userId);
        console.log(`üîì Thread ativa removida para ${userId}`);
        return true;
    }
    return false;
}

// ================================================
// üßπ FUN√á√ÉO DE LIMPEZA (mantida igual)
// ================================================

async function limparMensagensGuild(guild) {
    console.log(`üßπ Limpando mensagens antigas no servidor: ${guild.name}`);
    try {
        const channels = guild.channels.cache.filter(c => c.isTextBased() && !c.isThread());
        let totalDeleted = 0;

        for (const [channelId, channel] of channels) {
            try {
                if (channel.name.toLowerCase().includes(CANAL_LOG_FINALIZADOS.toLowerCase())) {
                    console.log(`üõ°Ô∏è Protegido: Pulando limpeza no canal ${channel.name} (canal de logs)`);
                    continue;
                }

                if (!channel.permissionsFor(guild.members.me)?.has(PermissionsBitField.Flags.ReadMessageHistory)) {
                    console.log(`‚ö†Ô∏è Bot sem permiss√£o de leitura em ${channel.name}. Ignorando limpeza.`);
                    continue;
                }

                const messages = await channel.messages.fetch({ limit: 50 });
                const botMessages = messages.filter(msg =>
                    msg.author.id === client.user.id &&
                    msg.createdTimestamp < Date.now() - 30000
                );

                for (const [msgId, message] of botMessages) {
                    try {
                        await message.delete();
                        mensagensOficiais.delete(msgId);
                        totalDeleted++;
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } catch (error) {
                        console.error(`‚ùå Erro ao deletar mensagem ${msgId} em ${channel.name}:`, error.message);
                    }
                }
            } catch (error) {
                console.error(`‚ùå Erro ao buscar mensagens no canal ${channel.name}:`, error.message);
            }
        }
        console.log(`‚úÖ ${totalDeleted} mensagens antigas removidas de ${guild.name} (${CANAL_LOG_FINALIZADOS} protegido)`);
    } catch (error) {
        console.error('‚ùå Erro geral na limpeza de mensagens:', error);
    }
}

// ================================================
// üì¢ POSTAGEM AUTOM√ÅTICA MULTI-JOGOS DIN√ÇMICA
// ================================================

async function postarServicosAutomatico(guild) {
    console.log(`üì¢ Postando servi√ßos multi-jogos em: ${guild.name}`);

    await limparMensagensGuild(guild);

    // üéÆ OBT√âM TODOS OS JOGOS ATIVOS
    const jogosAtivos = await obterJogosAtivos();

    // üåü MONTA SE√á√ÉO DE PRINCIPAIS SERVI√áOS DE TODOS OS JOGOS
    let secaoPrincipais = '';
    let totalDestaques = 0;

    for (const jogo of jogosAtivos) {
        const servicosDestaque = await obterServicosDestaquePorJogo(jogo.id);
        if (servicosDestaque.length > 0) {
            secaoPrincipais += `\n**${jogo.emoji} ${jogo.nome}:**\n`;
            secaoPrincipais += servicosDestaque.slice(0, 3).map(s => 
                `${s.emoji} ${s.nome} - **R$ ${s.preco.toFixed(2).replace('.', ',')}**`
            ).join('\n');
            secaoPrincipais += '\n';
            totalDestaques += servicosDestaque.length;
        }
    }

    const embed = new EmbedBuilder()
        .setTitle('üéÆ SERVI√áOS GAMING MULTI-JOGOS v2.2')
        .setDescription(
            '**‚ùó N√ÉO USO HACK - CHEATS! ‚ùó**\n\n' +
            'üõí **Sistema Profissional Multi-Jogos:**\n' +
            '‚Ä¢ Clique em üõí para abrir sua loja privada\n' +
            '‚Ä¢ Sistema de sele√ß√£o por jogo\n' +
            '‚Ä¢ Uma thread por cliente (sem duplicatas)\n' +
            '‚Ä¢ Numera√ß√£o sequencial autom√°tica\n' +
            '‚Ä¢ Controle administrativo Hellza\n\n' +

            '**üéØ PRINCIPAIS SERVI√áOS:**' + secaoPrincipais + '\n' +

            '**üéÆ JOGOS DISPON√çVEIS:**\n' +
            jogosAtivos.map(j => `${j.emoji} ${j.nome}`).join(' ‚Ä¢ ') + '\n\n' +

            '**üí° Diferenciais Exclusivos:**\n' +
            '‚úÖ Atendimento privado numerado\n' +
            '‚úÖ Sistema multi-jogos organizado\n' +
            '‚úÖ Controle anti-duplica√ß√£o\n' +
            '‚úÖ Sistema Hellza de finaliza√ß√£o\n' +
            '‚úÖ Organiza√ß√£o total dos pedidos\n' +
            '‚úÖ Pagamento PIX seguro e r√°pido\n\n' +

            '**üö® IMPORTANTE:**\n' +
            '‚Ä¢ Apenas 1 thread ativa por cliente\n' +
            '‚Ä¢ Reaja apenas nas mensagens oficiais\n' +
            '‚Ä¢ Aguarde finaliza√ß√£o antes de novo pedido\n\n' +

            '**üöÄ CLIQUE EM üõí PARA COME√áAR SEU ATENDIMENTO!**'
        )
        .setColor(0x00AE86)
        .setFooter({ 
            text: `Sistema Multi-Jogos v2.2 ‚Ä¢ ${jogosAtivos.length} Jogos ‚Ä¢ ${totalDestaques} Servi√ßos ‚Ä¢ Controle Hellza`,
            iconURL: guild.iconURL()
        })
        .setTimestamp();

    for (const nomeCanal of CANAIS_SERVICOS) {
        const canal = guild.channels.cache.find(c => 
            c.name.toLowerCase().includes(nomeCanal.toLowerCase()) && 
            c.isTextBased() && 
            !c.isThread()
        );

        if (canal) {
            try {
                const mensagem = await canal.send({ content: '@everyone', embeds: [embed] });
                await mensagem.react('üõí');

                try {
                    await mensagem.pin();
                    console.log(`üìå Mensagem multi-jogos fixada em: ${canal.name}`);
                } catch (pinError) {
                    console.error(`‚ùå Erro ao fixar mensagem em ${canal.name}:`, pinError.message);
                }

                mensagensOficiais.add(mensagem.id);
                console.log(`‚úÖ Mensagem oficial multi-jogos registrada: ${mensagem.id} em ${canal.name}`);

                await new Promise(resolve => setTimeout(resolve, 2000));
            } catch (error) {
                console.error(`‚ùå Erro ao postar em ${canal.name}:`, error.message);
            }
        } else {
            console.log(`‚ö†Ô∏è Canal '${nomeCanal}' n√£o encontrado em ${guild.name}`);
        }
    }
}

// ================================================
// üõí FUN√á√ïES DO CARRINHO MULTI-JOGOS
// ================================================

function getCarrinho(userId) {
    if (!carrinhos.has(userId)) {
        carrinhos.set(userId, { items: [], total: 0, jogoSelecionado: null });
    }
    return carrinhos.get(userId);
}

async function adicionarItem(userId, servicoId, quantidade = 1) {
    const carrinho = getCarrinho(userId);
    const servico = await getServico(servicoId);

    if (!servico) return false;

    const itemExistente = carrinho.items.find(item => item.id === servicoId);

    if (itemExistente) {
        itemExistente.quantidade += quantidade;
        itemExistente.subtotal = itemExistente.preco * itemExistente.quantidade;
    } else {
        carrinho.items.push({
            id: servicoId,
            jogo_id: servico.jogo_id,
            nome: servico.nome,
            preco: servico.preco,
            quantidade: quantidade,
            subtotal: servico.preco * quantidade,
            emoji: servico.emoji,
            tempo: servico.tempo
        });
    }

    carrinho.total = carrinho.items.reduce((sum, item) => sum + item.subtotal, 0);
    return true;
}

function removerItem(userId, servicoId) {
    const carrinho = getCarrinho(userId);
    carrinho.items = carrinho.items.filter(item => item.id !== servicoId);
    carrinho.total = carrinho.items.reduce((sum, item) => sum + item.subtotal, 0);
}

function limparCarrinho(userId) {
    carrinhos.set(userId, { items: [], total: 0, jogoSelecionado: null });
}

function selecionarJogo(userId, jogoId) {
    const carrinho = getCarrinho(userId);
    carrinho.jogoSelecionado = jogoId;
    // Limpa itens se mudou de jogo
    const itensDoJogo = carrinho.items.filter(item => item.jogo_id === jogoId);
    carrinho.items = itensDoJogo;
    carrinho.total = carrinho.items.reduce((sum, item) => sum + item.subtotal, 0);
}

// ================================================
// üìä LOG DE SERVI√áOS (mantido igual)
// ================================================

async function logarServicoFinalizado(guild, clienteMember, adminMember, threadName, carrinho) {
    try {
        const canalLog = guild.channels.cache.find(c => 
            c.name.toLowerCase().includes(CANAL_LOG_FINALIZADOS.toLowerCase()) && 
            c.isTextBased() && 
            !c.isThread()
        );

        if (!canalLog) {
            console.log(`‚ö†Ô∏è Canal de log '${CANAL_LOG_FINALIZADOS}' n√£o encontrado`);
            return false;
        }

        const totalValor = carrinho.total.toFixed(2).replace('.', ',');
        const totalItens = carrinho.items.reduce((sum, item) => sum + item.quantidade, 0);

        // üéÆ AGRUPA SERVI√áOS POR JOGO
        const servicosPorJogo = {};
        for (const item of carrinho.items) {
            if (!servicosPorJogo[item.jogo_id]) {
                servicosPorJogo[item.jogo_id] = [];
            }
            servicosPorJogo[item.jogo_id].push(item);
        }

        let listaServicos = '';
        for (const [jogoId, itens] of Object.entries(servicosPorJogo)) {
            const jogo = await getJogo(jogoId);
            listaServicos += `**${jogo ? jogo.emoji + ' ' + jogo.nome : jogoId}:**\n`;
            listaServicos += itens.map(item => 
                `${item.emoji} **${item.nome}** (${item.quantidade}x) - R$ ${item.subtotal.toFixed(2).replace('.', ',')}`
            ).join('\n') + '\n\n';
        }

        const embedLog = new EmbedBuilder()
            .setTitle('‚úÖ SERVI√áO MULTI-JOGOS FINALIZADO')
            .setDescription(
                `**üìã RESUMO DA TRANSA√á√ÉO**\n\n` +
                `üë§ **Cliente:** ${clienteMember.user.tag} (\`${clienteMember.id}\`)\n` +
                `üëë **Admin:** ${adminMember.user.tag} (\`${adminMember.id}\`)\n` +
                `üßµ **Thread:** ${threadName}\n` +
                `üìÖ **Data:** ${new Date().toLocaleString('pt-BR')}\n` +
                `üïê **Timestamp:** <t:${Math.floor(Date.now() / 1000)}:F>`
            )
            .addFields([
                { 
                    name: 'üéÆ Servi√ßos Realizados', 
                    value: listaServicos || 'Nenhum servi√ßo encontrado', 
                    inline: false 
                },
                { 
                    name: 'üìä Total de Itens', 
                    value: `${totalItens} itens`, 
                    inline: true 
                },
                { 
                    name: 'üí∞ Valor Total', 
                    value: `R$ ${totalValor}`, 
                    inline: true 
                },
                { 
                    name: 'üè∑Ô∏è Status', 
                    value: 'Finalizado ‚úÖ', 
                    inline: true 
                }
            ])
            .setColor(0x00FF00)
            .setThumbnail(clienteMember.user.displayAvatarURL())
            .setFooter({ 
                text: `Sistema Multi-Jogos Hellza ‚Ä¢ ID: ${Date.now()}`, 
                iconURL: guild.iconURL() 
            })
            .setTimestamp();

        await canalLog.send({ embeds: [embedLog] });
        console.log(`üìä Log multi-jogos enviado para ${canalLog.name}: ${clienteMember.user.tag} | R$ ${totalValor}`);
        return true;

    } catch (error) {
        console.error('‚ùå Erro ao enviar log de servi√ßo finalizado:', error);
        return false;
    }
}

// ================================================
// üéÆ INTERFACES DIN√ÇMICAS MULTI-JOGOS
// ================================================

async function criarDropdownJogos() {
    const jogosAtivos = await obterJogosAtivos();

    const options = jogosAtivos.map(jogo => 
        new StringSelectMenuOptionBuilder()
            .setLabel(jogo.nome)
            .setDescription(jogo.descricao)
            .setValue(jogo.id)
            .setEmoji(jogo.emoji)
    );

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('select_jogo')
        .setPlaceholder('üéÆ Primeiro, escolha o jogo')
        .setMinValues(1)
        .setMaxValues(1)
        .addOptions(options);

    return new ActionRowBuilder().addComponents(selectMenu);
}

async function criarDropdownServicos(jogoId) {
    const servicosDoJogo = await obterServicosPorJogo(jogoId);
    const servicosArray = servicosDoJogo.slice(0, 25); // M√°ximo 25 op√ß√µes

    if (servicosArray.length === 0) {
        return null;
    }

    const options = servicosArray.map(servico => 
        new StringSelectMenuOptionBuilder()
            .setLabel(`${servico.nome}`)
            .setDescription(`R$ ${servico.preco.toFixed(2).replace('.', ',')} ‚Ä¢ ${servico.tempo}`)
            .setValue(servico.id)
            .setEmoji(servico.emoji)
    );

    const jogo = await getJogo(jogoId);
    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('select_servico')
        .setPlaceholder(`${jogo.emoji} Escolha um servi√ßo de ${jogo.nome}`)
        .setMinValues(1)
        .setMaxValues(1)
        .addOptions(options);

    return new ActionRowBuilder().addComponents(selectMenu);
}

function criarDropdownQuantidade(servicoId) {
    const options = [];
    for (let i = 1; i <= 10; i++) {
        options.push(
            new StringSelectMenuOptionBuilder()
                .setLabel(`${i}x`)
                .setDescription(`Adicionar ${i} ${i === 1 ? 'unidade' : 'unidades'}`)
                .setValue(`${servicoId}_${i}`)
        );
    }

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('select_quantidade')
        .setPlaceholder('üì¶ Escolha a quantidade')
        .setMinValues(1)
        .setMaxValues(1)
        .addOptions(options);

    return new ActionRowBuilder().addComponents(selectMenu);
}

async function criarCarrinhoEmbed(userId, user) {
    const carrinho = getCarrinho(userId);

    if (carrinho.items.length === 0) {
        const jogoSelecionado = carrinho.jogoSelecionado ? await getJogo(carrinho.jogoSelecionado) : null;

        return new EmbedBuilder()
            .setTitle('üõí Carrinho Multi-Jogos - ' + user.displayName)
            .setDescription(
                jogoSelecionado ? 
                `**Jogo selecionado:** ${jogoSelecionado.emoji} ${jogoSelecionado.nome}\n\n**Carrinho vazio**\n\nüéÆ Selecione servi√ßos no menu para come√ßar!` :
                '**Carrinho vazio**\n\nüéÆ Primeiro escolha um jogo, depois selecione os servi√ßos!'
            )
            .addFields([
                { name: 'üí∞ Total', value: 'R$ 0,00', inline: true },
                { name: 'üì¶ Itens', value: '0', inline: true },
                { name: '‚è±Ô∏è Status', value: 'Aguardando', inline: true }
            ])
            .setColor(0x5865F2)
            .setTimestamp();
    }

    // üéÆ AGRUPA ITENS POR JOGO
    const itensPorJogo = {};
    for (const item of carrinho.items) {
        if (!itensPorJogo[item.jogo_id]) {
            itensPorJogo[item.jogo_id] = [];
        }
        itensPorJogo[item.jogo_id].push(item);
    }

    let itensLista = '';
    for (const [jogoId, itens] of Object.entries(itensPorJogo)) {
        const jogo = await getJogo(jogoId);
        itensLista += `**${jogo ? jogo.emoji + ' ' + jogo.nome : jogoId}:**\n`;
        itensLista += itens.map((item, index) => 
            `${index + 1}. ${item.emoji} **${item.nome}** (**${item.quantidade}x**)\n` +
            `   üí∞ R$ ${item.subtotal.toFixed(2).replace('.', ',')} ‚Ä¢ ‚è±Ô∏è ${item.tempo}`
        ).join('\n') + '\n\n';
    }

    return new EmbedBuilder()
        .setTitle(`üõí Carrinho Multi-Jogos - ${user.displayName}`)
        .setDescription(`üéâ **Seus servi√ßos selecionados:**\n\n${itensLista}`)
        .addFields([
            { name: 'üí∞ VALOR TOTAL', value: `**R$ ${carrinho.total.toFixed(2).replace('.', ',')}**`, inline: true },
            { name: 'üì¶ Total de Itens', value: carrinho.items.reduce((sum, item) => sum + item.quantidade, 0).toString(), inline: true },
            { name: '‚è±Ô∏è Status', value: 'Pronto para finalizar', inline: true }
        ])
        .setColor(0x00D4AA)
        .setFooter({ text: `${carrinho.items.length} tipos de servi√ßos ‚Ä¢ Sistema Multi-Jogos` })
        .setTimestamp();
}

async function criarPagamentoEmbed(userId, user) {
    const carrinho = getCarrinho(userId);

    // üéÆ AGRUPA ITENS POR JOGO PARA RESUMO
    const itensPorJogo = {};
    for (const item of carrinho.items) {
        if (!itensPorJogo[item.jogo_id]) {
            itensPorJogo[item.jogo_id] = [];
        }
        itensPorJogo[item.jogo_id].push(item);
    }

    let resumoDetalhado = '';
    let contador = 1;
    for (const [jogoId, itens] of Object.entries(itensPorJogo)) {
        const jogo = await getJogo(jogoId);
        resumoDetalhado += `**${jogo ? jogo.emoji + ' ' + jogo.nome : jogoId}:**\n`;
        resumoDetalhado += itens.map(item => 
            `**${contador++}.** ${item.emoji} **${item.nome}** (**${item.quantidade}x**)\n` +
            `    üí∞ R$ ${item.subtotal.toFixed(2).replace('.', ',')} ‚Ä¢ ‚è±Ô∏è ${item.tempo}`
        ).join('\n') + '\n\n';
    }

    const totalItens = carrinho.items.reduce((sum, item) => sum + item.quantidade, 0);

    return new EmbedBuilder()
        .setTitle('üí≥ üéâ PEDIDO MULTI-JOGOS FINALIZADO!')
        .setDescription(
            `**Parab√©ns ${user.displayName}!**\n\n` +
            `**üìã RESUMO DO PEDIDO:**\n\n${resumoDetalhado}` +
            `üì¶ **TOTAL DE SERVI√áOS:** ${totalItens}\n` +
            `üí∞ **VALOR TOTAL:** R$ ${carrinho.total.toFixed(2).replace('.', ',')}`
        )
        .addFields([
            { 
                name: 'üí≥ Dados PIX', 
                value: `**Chave:** ${PIX_CONFIG.chave}\n**Nome:** ${PIX_CONFIG.nome}\n**Banco:** ${PIX_CONFIG.banco}`,
                inline: false 
            },
            { 
                name: 'üì± Instru√ß√µes', 
                value: 
                    `1Ô∏è‚É£ Fa√ßa PIX: **R$ ${carrinho.total.toFixed(2).replace('.', ',')}**\n` +
                    `2Ô∏è‚É£ Envie comprovante aqui\n` +
                    `3Ô∏è‚É£ Aguarde confirma√ß√£o Hellza\n` +
                    `4Ô∏è‚É£ Servi√ßos iniciados ap√≥s confirma√ß√£o`,
                inline: false 
            },
            { 
                name: 'üîÑ Pr√≥ximo Passo', 
                value: 'Aguardando comprovante e confirma√ß√£o administrativa Hellza.',
                inline: false 
            }
        ])
        .setColor(0x32CD32)
        .setFooter({ text: '‚ö†Ô∏è Thread √∫nica ‚Ä¢ Sistema Multi-Jogos ‚Ä¢ Bot√£o exclusivo para Administradores' })
        .setTimestamp();
}

function criarBotoesCarrinho() {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('atualizar_carrinho')
                .setLabel('üîÑ')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('trocar_jogo')
                .setLabel('üéÆ Trocar Jogo')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setCustomId('remover_item')
                .setLabel('‚ûñ Remover')
                .setStyle(ButtonStyle.Danger),
            new ButtonBuilder()
                .setCustomId('limpar_carrinho')
                .setLabel('üßπ Limpar')
                .setStyle(ButtonStyle.Danger),
            new ButtonBuilder()
                .setCustomId('finalizar_pedido')
                .setLabel('üí≥ Finalizar')
                .setStyle(ButtonStyle.Success)
        );
}

function criarBotaoAdminFinalizar(threadId) {
    return new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId(`admin_finalizar_${threadId}`)
                .setLabel('üëë FINALIZAR SERVI√áO')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('‚úÖ')
        );
}

function criarDropdownRemover(userId) {
    const carrinho = getCarrinho(userId);

    if (carrinho.items.length === 0) return null;

    const options = carrinho.items.map(item => 
        new StringSelectMenuOptionBuilder()
            .setLabel(`${item.nome} (${item.quantidade}x)`)
            .setDescription(`R$ ${item.subtotal.toFixed(2).replace('.', ',')}`)
            .setValue(item.id)
            .setEmoji(item.emoji)
    );

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('confirmar_remocao')
        .setPlaceholder('üóëÔ∏è Escolha o item para remover')
        .setMinValues(1)
        .setMaxValues(1)
        .addOptions(options);

    return new ActionRowBuilder().addComponents(selectMenu);
}


// ================================================
// üéõÔ∏è COMANDOS ADMINISTRATIVOS MULTI-JOGOS + TUTORIAL
// ================================================

const comandos = [
    // üìö TUTORIAL DE COMANDOS
    new SlashCommandBuilder()
        .setName('tutorial')
        .setDescription('üëë [ADMIN] Tutorial completo de todos os comandos administrativos'),

    // üéÆ GERENCIAR JOGOS
    new SlashCommandBuilder()
        .setName('addjogo')
        .setDescription('üëë [ADMIN] Adicionar novo jogo')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID √∫nico do jogo (ex: valorant)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('nome')
                .setDescription('Nome do jogo (ex: Valorant)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('emoji')
                .setDescription('Emoji do jogo (ex: üéØ)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('descricao')
                .setDescription('Descri√ß√£o do jogo')
                .setRequired(true))
        .addBooleanOption(option =>
            option.setName('ativo')
                .setDescription('Jogo ativo? (padr√£o: true)')
                .setRequired(false))
        .addIntegerOption(option =>
            option.setName('ordem')
                .setDescription('Ordem de exibi√ß√£o (menor n√∫mero = aparece primeiro)')
                .setRequired(false)),

    new SlashCommandBuilder()
        .setName('editjogo')
        .setDescription('üëë [ADMIN] Editar jogo existente')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do jogo para editar')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('campo')
                .setDescription('Campo a editar')
                .setRequired(true)
                .addChoices(
                    { name: 'Nome', value: 'nome' },
                    { name: 'Emoji', value: 'emoji' },
                    { name: 'Descri√ß√£o', value: 'descricao' },
                    { name: 'Ativo', value: 'ativo' },
                    { name: 'Ordem', value: 'ordem' }
                ))
        .addStringOption(option =>
            option.setName('valor')
                .setDescription('Novo valor para o campo')
                .setRequired(true)),

    new SlashCommandBuilder()
        .setName('removejogo')
        .setDescription('üëë [ADMIN] Remover jogo (cuidado: remove TODOS os servi√ßos)')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do jogo para remover')
                .setRequired(true)),

    new SlashCommandBuilder()
        .setName('listjogos')
        .setDescription('üëë [ADMIN] Listar todos os jogos'),

    // üõ†Ô∏è GERENCIAR SERVI√áOS
    new SlashCommandBuilder()
        .setName('addservico')
        .setDescription('üëë [ADMIN] Adicionar novo servi√ßo')
        .addStringOption(option =>
            option.setName('jogo')
                .setDescription('ID do jogo (ex: zenless-zone-zero)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID √∫nico do servi√ßo (ex: farm-premium)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('nome')
                .setDescription('Nome do servi√ßo (ex: Farm Premium)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('descricao')
                .setDescription('Descri√ß√£o detalhada do servi√ßo')
                .setRequired(true))
        .addNumberOption(option =>
            option.setName('preco')
                .setDescription('Pre√ßo em reais (ex: 50.00)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('tempo')
                .setDescription('Tempo estimado (ex: 2-3 horas)')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('emoji')
                .setDescription('Emoji para o servi√ßo (ex: üÜï)')
                .setRequired(true))
        .addBooleanOption(option =>
            option.setName('destaque')
                .setDescription('Aparece nos PRINCIPAIS SERVI√áOS? (padr√£o: false)')
                .setRequired(false))
        .addIntegerOption(option =>
            option.setName('ordem')
                .setDescription('Ordem de exibi√ß√£o (n√∫mero menor = aparece primeiro)')
                .setRequired(false)),

    new SlashCommandBuilder()
        .setName('editservico')
        .setDescription('üëë [ADMIN] Editar servi√ßo existente')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do servi√ßo para editar')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('campo')
                .setDescription('Campo a editar')
                .setRequired(true)
                .addChoices(
                    { name: 'Nome', value: 'nome' },
                    { name: 'Descri√ß√£o', value: 'descricao' },
                    { name: 'Pre√ßo', value: 'preco' },
                    { name: 'Tempo', value: 'tempo' },
                    { name: 'Emoji', value: 'emoji' },
                    { name: 'Destaque', value: 'destaque' },
                    { name: 'Ordem', value: 'ordem' },
                    { name: 'Jogo', value: 'jogo_id' }
                ))
        .addStringOption(option =>
            option.setName('valor')
                .setDescription('Novo valor para o campo')
                .setRequired(true)),

    new SlashCommandBuilder()
        .setName('removeservico')
        .setDescription('üëë [ADMIN] Remover servi√ßo')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do servi√ßo para remover')
                .setRequired(true)),

    new SlashCommandBuilder()
        .setName('listservicos')
        .setDescription('üëë [ADMIN] Listar servi√ßos')
        .addStringOption(option =>
            option.setName('jogo')
                .setDescription('Filtrar por jogo (opcional)')
                .setRequired(false))
        .addStringOption(option =>
            option.setName('filtro')
                .setDescription('Filtrar por tipo')
                .setRequired(false)
                .addChoices(
                    { name: 'Todos', value: 'todos' },
                    { name: 'Em Destaque', value: 'destaque' },
                    { name: 'Padr√£o', value: 'padrao' }
                )),

    // üí∞ GERENCIAR PRE√áOS
    new SlashCommandBuilder()
        .setName('precoservico')
        .setDescription('üëë [ADMIN] Alterar pre√ßo de um servi√ßo')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do servi√ßo')
                .setRequired(true))
        .addNumberOption(option =>
            option.setName('preco')
                .setDescription('Novo pre√ßo em reais')
                .setRequired(true)),

    new SlashCommandBuilder()
        .setName('destacarservico')
        .setDescription('üëë [ADMIN] Colocar/tirar servi√ßo do destaque')
        .addStringOption(option =>
            option.setName('id')
                .setDescription('ID do servi√ßo')
                .setRequired(true))
        .addBooleanOption(option =>
            option.setName('destaque')
                .setDescription('Destacar? (true/false)')
                .setRequired(true)),

    // üìä SISTEMA
    new SlashCommandBuilder()
        .setName('recarregarmensagens')
        .setDescription('üëë [ADMIN] Recarregar mensagens com jogos e servi√ßos atualizados'),

    new SlashCommandBuilder()
        .setName('estatisticas')
        .setDescription('üëë [ADMIN] Ver estat√≠sticas do sistema')
];

// ================================================
// üåü EVENT: BOT CONECTADO MULTI-JOGOS
// ================================================

client.once(Events.ClientReady, async () => {
    console.log(`ü§ñ Bot MULTI-JOGOS online: ${client.user.tag}!`);
    console.log(`üëë Cargo principal: ${CARGO_ADMIN_PRINCIPAL}`);
    console.log(`üë• Cargos suporte: ${CARGOS_SUPORTE.join(', ')}`);
    console.log(`üìä Canal de log: ${CANAL_LOG_FINALIZADOS}`);

    console.log('‚öôÔ∏è Vari√°veis PIX:', {
        chave: process.env.PIX_CHAVE || 'N√ÉO CONFIGURADA',
        nome: process.env.PIX_NOME || 'N√ÉO CONFIGURADA',
        banco: process.env.PIX_BANCO || 'N√ÉO CONFIGURADA'
    });

    console.log('üéõÔ∏è Registrando comandos administrativos multi-jogos...');
    try {
        const data = await client.application.commands.set(comandos);
        console.log(`‚úÖ ${data.size} comandos administrativos registrados!`);
    } catch (error) {
        console.error('‚ùå Erro ao registrar comandos:', error);
    }

    console.log('üéÆ Inicializando sistema multi-jogos...');
    global.jogosDisponiveis = await inicializarJogos();
    global.servicosCompletos = await inicializarServicos();

    const totalJogos = Object.keys(global.jogosDisponiveis).length;
    const jogosAtivos = await obterJogosAtivos();
    const totalServicos = Object.keys(global.servicosCompletos).length;

    console.log(`üéÆ ${totalJogos} jogos carregados (${jogosAtivos.length} ativos)`);
    console.log(`üìä ${totalServicos} servi√ßos carregados`);
    console.log(`üîí Sistema anti-duplica√ß√£o ativo`);

    client.user.setActivity(`üéÆ ${jogosAtivos.length} Jogos ‚Ä¢ ${totalServicos} Servi√ßos`, { type: 'PLAYING' });

    setTimeout(async () => {
        console.log('üßπ Iniciando configura√ß√£o autom√°tica multi-jogos...');

        for (const [guildId, guild] of client.guilds.cache) {
            try {
                await postarServicosAutomatico(guild);
                console.log(`‚úÖ Servidor ${guild.name} configurado com sistema multi-jogos!`);
            } catch (error) {
                console.error(`‚ùå Erro ao configurar o servidor ${guild.name}:`, error);
            }
        }

        console.log('üöÄ Sistema multi-jogos totalmente ativo!');
    }, 5000);
});

// ================================================
// üõí EVENT: REA√á√ïES MULTI-JOGOS
// ================================================

client.on(Events.MessageReactionAdd, async (reaction, user) => {
    if (user.bot) return;

    if (reaction.partial) {
        try {
            await reaction.fetch();
        } catch (error) {
            console.error('Erro ao buscar rea√ß√£o parcial:', error);
            return;
        }
    }

    if (reaction.emoji.name === 'üõí') {
        if (!mensagensOficiais.has(reaction.message.id)) {
            console.log(`üö´ Rea√ß√£o em mensagem n√£o oficial ignorada: ${reaction.message.id} por ${user.tag}`);
            await reaction.users.remove(user.id);

            try {
                await user.send(
                    `üö´ **Aten√ß√£o ${user.displayName}!**\n\n` +
                    `Voc√™ reagiu com üõí em uma mensagem n√£o oficial.\n\n` +
                    `‚úÖ **Para criar sua loja privada:**\n` +
                    `‚Ä¢ Reaja üõí apenas nas **mensagens fixadas** do bot\n` +
                    `‚Ä¢ Procure por mensagens com t√≠tulo "SERVI√áOS GAMING MULTI-JOGOS"\n` +
                    `‚Ä¢ S√£o as mensagens **oficiais** e **fixadas** nos canais\n\n` +
                    `üîç Volte aos canais e procure pela mensagem oficial fixada!`
                );
            } catch (dmError) {
                console.log(`‚ùå N√£o foi poss√≠vel enviar DM para ${user.tag}:`, dmError.message);
            }

            return;
        }

        const guild = reaction.message.guild;
        const member = guild.members.cache.get(user.id);

        if (member && isQualquerAdmin(member)) {
            console.log(`üëë Admin ${user.tag} reagiu ao carrinho - permitindo acesso especial`);
            await reaction.users.remove(user.id);

            try {
                await user.send(
                    `üëë **Acesso Administrativo Multi-Jogos - ${user.displayName}**\n\n` +
                    `Voc√™ √© um administrador e reagiu ao sistema de carrinho.\n\n` +
                    `‚ö†Ô∏è **Nota:** Administradores n√£o precisam criar threads de cliente.\n` +
                    `üìä **Fun√ß√£o:** Voc√™s gerenciam as threads criadas pelos clientes.\n\n` +
                    `üéõÔ∏è **Comandos dispon√≠veis:** /tutorial para ver todos os comandos\n` +
                    `üîß **Para testes:** Se quiser testar como cliente, pe√ßa para algu√©m sem cargo admin reagir ao üõí.\n\n` +
                    `‚úÖ **Sistema multi-jogos funcionando normalmente!**`
                );
            } catch (dmError) {
                console.log(`‚ùå N√£o foi poss√≠vel enviar DM para admin ${user.tag}:`, dmError.message);
            }

            return;
        }

        if (temThreadAtiva(user.id)) {
            const threadAtivaId = getThreadAtiva(user.id);
            const threadAtiva = guild.channels.cache.get(threadAtivaId);

            console.log(`üö´ ${user.tag} tentou criar nova thread tendo uma ativa: ${threadAtivaId}`);

            await reaction.users.remove(user.id);

            let mensagemAviso = `üö´ **${user.displayName}, voc√™ j√° tem uma thread ativa!**\n\n`;

            if (threadAtiva && !threadAtiva.archived) {
                mensagemAviso += `üìç **Sua thread ativa:** ${threadAtiva.name}\n`;
                mensagemAviso += `üîó Acesse sua thread existente para continuar suas compras.\n\n`;
            } else {
                removerThreadAtiva(user.id);
                mensagemAviso += `üîÑ **Thread anterior n√£o encontrada.** Tente reagir novamente.\n\n`;
            }

            mensagemAviso += `‚ö†Ô∏è **Regra:** Apenas 1 thread por cliente.\n`;
            mensagemAviso += `‚úÖ **Aguarde a finaliza√ß√£o** pela equipe Hellza antes de criar nova thread.`;

            try {
                await user.send(mensagemAviso);
            } catch (dmError) {
                const confirmMsg = await reaction.message.channel.send(
                    `üö´ ${user}, voc√™ j√° tem uma thread ativa! Finalize-a antes de criar outra.`
                );
                setTimeout(() => confirmMsg.delete().catch(() => {}), 10000);
            }

            return;
        }

        const numeroThread = getProximoNumeroThread(user.id);
        const nomeThread = `üõí-loja-${user.username}-${numeroThread}`;

        console.log(`üî¢ Criando thread multi-jogos ${numeroThread} para ${user.tag}: ${nomeThread}`);

        try {
            const thread = await reaction.message.channel.threads.create({
                name: nomeThread,
                type: ChannelType.PublicThread,
                autoArchiveDuration: ThreadAutoArchiveDuration.OneDay,
                reason: `Loja multi-jogos ${numeroThread} para ${user.tag}`,
                invitable: false
            });

            await thread.permissionOverwrites.edit(thread.guild.roles.everyone, {
                ViewChannel: false,
                SendMessages: false,
                ReadMessageHistory: false
            });

            await thread.permissionOverwrites.edit(user.id, {
                ViewChannel: true,
                SendMessages: true,
                AttachFiles: true,
                ReadMessageHistory: true,
                UseExternalEmojis: true,
                AddReactions: true
            });

            marcarThreadAtiva(user.id, thread.id);
            await thread.members.add(user.id);
            console.log(`üë§ ${user.tag} adicionado √† thread multi-jogos ${numeroThread} com permiss√µes completas`);

            let hellzaAdmins = 0;
            let suporteAdmins = 0;

            try {
                await guild.members.fetch();
            } catch (fetchError) {
                console.log('‚ö†Ô∏è Erro ao buscar membros, usando cache atual');
            }

            const hellzaRole = guild.roles.cache.find(role => 
                role.name.toLowerCase() === CARGO_ADMIN_PRINCIPAL.toLowerCase()
            );

            if (hellzaRole) {
                await thread.permissionOverwrites.edit(hellzaRole, {
                    ViewChannel: true,
                    SendMessages: true,
                    AttachFiles: true,
                    ReadMessageHistory: true,
                    ManageMessages: true,
                    ManageThreads: true
                });

                const hellzaMembers = guild.members.cache.filter(member => 
                    member.roles.cache.has(hellzaRole.id) && !member.user.bot
                );

                for (const [memberId, hellzaMember] of hellzaMembers) {
                    try {
                        await thread.members.add(hellzaMember.id);
                        console.log(`üëë Hellza Admin ${hellzaMember.user.tag} adicionado`);
                        hellzaAdmins++;
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (error) {
                        console.error(`‚ùå Erro ao adicionar Hellza ${hellzaMember.user.tag}:`, error.message);
                    }
                }
            }

            for (const cargoNome of CARGOS_SUPORTE) {
                const cargoSuporte = guild.roles.cache.find(role =>
                    role.name.toLowerCase().includes(cargoNome.toLowerCase())
                );

                if (cargoSuporte && cargoSuporte.id !== hellzaRole?.id) {
                    await thread.permissionOverwrites.edit(cargoSuporte, {
                        ViewChannel: true,
                        SendMessages: true,
                        AttachFiles: true,
                        ReadMessageHistory: true
                    });

                    const suporteMembers = guild.members.cache.filter(member => 
                        member.roles.cache.has(cargoSuporte.id) && !member.user.bot
                    );

                    for (const [memberId, supportMember] of suporteMembers) {
                        try {
                            await thread.members.add(supportMember.id);
                            console.log(`üë• Suporte ${supportMember.user.tag} adicionado (cargo: ${cargoSuporte.name})`);
                            suporteAdmins++;
                            await new Promise(resolve => setTimeout(resolve, 300));
                        } catch (error) {
                            console.error(`‚ùå Erro ao adicionar suporte ${supportMember.user.tag}:`, error.message);
                        }
                    }
                }
            }

            const totalAdmins = hellzaAdmins + suporteAdmins;
            const jogosAtivos = await obterJogosAtivos();
            const totalServicos = Object.keys(global.servicosCompletos).length;

            console.log(`‚úÖ Thread multi-jogos ${numeroThread}: ${hellzaAdmins} Hellza + ${suporteAdmins} suporte = ${totalAdmins} admins`);

            await new Promise(resolve => setTimeout(resolve, 2000));

            const welcomeEmbed = new EmbedBuilder()
                .setTitle(`üéâ Loja Multi-Jogos Exclusiva #${numeroThread} - ${user.displayName}`)
                .setDescription(
                    `**Bem-vindo √† sua loja multi-jogos exclusiva!** üõí‚ú®\n\n` +
                    `**üî¢ Thread N√∫mero:** ${numeroThread}\n` +
                    `**üîí Status:** Thread √∫nica ativa\n` +
                    `**üëë Hellza Admins:** ${hellzaAdmins}\n` +
                    `**üë• Equipe Suporte:** ${suporteAdmins}\n` +
                    `**üìä Total da Equipe:** ${totalAdmins}\n` +
                    `**üéÆ Jogos Dispon√≠veis:** ${jogosAtivos.length}\n` +
                    `**üõ†Ô∏è Total de Servi√ßos:** ${totalServicos}\n\n` +

                    '**üéØ Sistema Multi-Jogos:**\n' +
                    '‚Ä¢ Primeiro escolha o jogo\n' +
                    '‚Ä¢ Depois selecione os servi√ßos\n' +
                    '‚Ä¢ Sistema de dropdown em cascata\n' +
                    '‚Ä¢ Controle por jogo organizado\n\n' +

                    '**üõ°Ô∏è Conversa privada e protegida**\n' +
                    'Thread exclusiva com controle total da administra√ß√£o\n\n' +

                    '**üí¨ AGORA VOC√ä PODE:**\n' +
                    '‚úÖ Enviar mensagens de texto\n' +
                    '‚úÖ Enviar comprovantes PIX (imagens)\n' +
                    '‚úÖ Tirar d√∫vidas com a equipe\n' +
                    '‚úÖ Usar todos os bot√µes e menus\n\n' +

                    '**‚ö†Ô∏è IMPORTANTE:**\n' +
                    '‚Ä¢ N√ÉO usamos hack/cheats - Servi√ßos leg√≠timos\n' +
                    '‚Ä¢ Aguarde finaliza√ß√£o Hellza para nova thread\n' +
                    '‚Ä¢ Esta √© sua thread exclusiva at√© finaliza√ß√£o'
                )
                .setColor(0x00AE86)
                .setThumbnail(user.displayAvatarURL())
                .setFooter({ text: `Sistema Multi-Jogos v2.2 ‚Ä¢ Thread ${numeroThread} ‚Ä¢ ${jogosAtivos.length} Jogos ‚Ä¢ Cliente pode falar!` })
                .setTimestamp();

            // üéÆ COME√áA COM DROPDOWN DE JOGOS
            const dropdownJogos = await criarDropdownJogos();
            const buttonsCarrinho = criarBotoesCarrinho();
            const carrinhoEmbed = await criarCarrinhoEmbed(user.id, user);

            await thread.send({ embeds: [welcomeEmbed] });
            await new Promise(resolve => setTimeout(resolve, 1500));
            await thread.send({ 
                embeds: [carrinhoEmbed],
                components: [dropdownJogos, buttonsCarrinho]
            });

            console.log(`üõí Loja multi-jogos ${numeroThread} aberta para ${user.tag} com ${totalAdmins} admins`);
            await reaction.users.remove(user.id);

            const confirmMsg = await reaction.message.channel.send(
                `‚úÖ ${user}, loja multi-jogos exclusiva **#${numeroThread}** criada! üõíüéÆ\n` +
                `üëë **${hellzaAdmins} Hellza** + **${suporteAdmins} suporte** = **${totalAdmins} total** na equipe!\n` +
                `üéÆ **${jogosAtivos.length} jogos** e **${totalServicos} servi√ßos** dispon√≠veis!\n` +
                `üí¨ **Agora voc√™ pode conversar normalmente na thread!**`
            );
            setTimeout(() => confirmMsg.delete().catch(() => {}), 15000);

        } catch (error) {
            console.error(`‚ùå Erro cr√≠tico ao criar thread multi-jogos para ${user.tag}:`, error);
            removerThreadAtiva(user.id);

            try {
                await user.send(
                    `‚ùå **Ocorreu um erro ao criar sua loja multi-jogos.** Por favor, tente novamente mais tarde ou contate um administrador.`
                );
            } catch (dmError) {
                console.error(`‚ùå N√£o foi poss√≠vel enviar DM de erro para ${user.tag}:`, dmError.message);
            }
        }
    }
});

// ================================================
// üóëÔ∏è EVENT: THREAD DELETADA/ARQUIVADA
// ================================================

client.on(Events.ThreadDelete, (thread) => {
    for (const [userId, threadId] of threadsAtivas.entries()) {
        if (threadId === thread.id) {
            removerThreadAtiva(userId);
            console.log(`üóëÔ∏è Thread multi-jogos ${thread.name} deletada, controle removido para usu√°rio ${userId}`);
            break;
        }
    }
});

client.on(Events.ThreadUpdate, (oldThread, newThread) => {
    if (newThread.archived && !oldThread.archived) {
        for (const [userId, threadId] of threadsAtivas.entries()) {
            if (threadId === newThread.id) {
                removerThreadAtiva(userId);
                console.log(`üì¶ Thread multi-jogos ${newThread.name} arquivada, controle removido para usu√°rio ${userId}`);
                break;
            }
        }
    }
});


// ================================================
// üéõÔ∏è EVENT: INTERA√á√ïES COMPLETAS MULTI-JOGOS
// ================================================

client.on(Events.InteractionCreate, async (interaction) => {
    // ================================================
    // üéõÔ∏è COMANDOS ADMINISTRATIVOS MULTI-JOGOS
    // ================================================
    if (interaction.isChatInputCommand()) {
        const { commandName, member, options } = interaction;

        if (!isQualquerAdmin(member)) {
            await interaction.reply({
                content: 'üö´ **ACESSO NEGADO**\n\n‚ùå Apenas administradores podem usar comandos de gerenciamento.\n\nüëë **Cargos autorizados:** Hellza, Admin, Moderador, Staff, Suporte.\n\nüí° **Dica:** Use /tutorial para ver todos os comandos (apenas admins).',
                ephemeral: true
            });
            return;
        }

        try {
            // üìö TUTORIAL COMPLETO
            if (commandName === 'tutorial') {
                const tutorialEmbed = new EmbedBuilder()
                    .setTitle('üìö TUTORIAL COMPLETO - COMANDOS ADMINISTRATIVOS')
                    .setDescription('**Sistema Multi-Jogos v2.2 - Guia Completo para Administradores** üëë')
                    .addFields([
                        {
                            name: 'üéÆ **GERENCIAR JOGOS**',
                            value: 
                                '`/addjogo` - Adicionar novo jogo\n' +
                                '`/editjogo` - Editar jogo existente\n' +
                                '`/removejogo` - Remover jogo (cuidado!)\n' +
                                '`/listjogos` - Listar todos os jogos',
                            inline: false
                        },
                        {
                            name: 'üõ†Ô∏è **GERENCIAR SERVI√áOS**',
                            value: 
                                '`/addservico` - Adicionar servi√ßo (precisa do jogo)\n' +
                                '`/editservico` - Editar servi√ßo existente\n' +
                                '`/removeservico` - Remover servi√ßo\n' +
                                '`/listservicos` - Listar servi√ßos (filtros por jogo)',
                            inline: false
                        },
                        {
                            name: 'üí∞ **PRE√áOS E DESTAQUES**',
                            value: 
                                '`/precoservico` - Alterar pre√ßo rapidamente\n' +
                                '`/destacarservico` - Colocar/tirar do destaque',
                            inline: false
                        },
                        {
                            name: 'üìä **SISTEMA**',
                            value: 
                                '`/recarregarmensagens` - Atualizar mensagens\n' +
                                '`/estatisticas` - Ver stats do sistema\n' +
                                '`/tutorial` - Este tutorial',
                            inline: false
                        },
                        {
                            name: '‚ú® **EXEMPLOS PR√ÅTICOS**',
                            value: 
                                '**Novo jogo:**\n' +
                                '`/addjogo id:valorant nome:Valorant emoji:üéØ descricao:Servi√ßos Valorant`\n\n' +
                                '**Novo servi√ßo:**\n' +
                                '`/addservico jogo:valorant id:boost-rank nome:Boost de Rank preco:80.00 tempo:2-3 dias emoji:‚¨ÜÔ∏è destaque:true`\n\n' +
                                '**Alterar pre√ßo:**\n' +
                                '`/precoservico id:boost-rank preco:90.00`\n\n' +
                                '**Destacar servi√ßo:**\n' +
                                '`/destacarservico id:boost-rank destaque:true`',
                            inline: false
                        },
                        {
                            name: 'üö® **IMPORTANTES**',
                            value: 
                                '‚Ä¢ **IDs devem ser √∫nicos** (sem espa√ßos)\n' +
                                '‚Ä¢ **Pre√ßos em formato 99.99** (ponto, n√£o v√≠rgula)\n' +
                                '‚Ä¢ **Destaque = aparece na mensagem principal**\n' +
                                '‚Ä¢ **Ordem menor = aparece primeiro**\n' +
                                '‚Ä¢ **Sempre usar /recarregarmensagens** ap√≥s mudan√ßas\n' +
                                '‚Ä¢ **Remover jogo = remove TODOS seus servi√ßos**',
                            inline: false
                        }
                    ])
                    .setColor(0x0099FF)
                    .setFooter({ 
                        text: 'Sistema Multi-Jogos ‚Ä¢ Apenas Administradores ‚Ä¢ Use com responsabilidade üëë',
                        iconURL: interaction.guild.iconURL()
                    })
                    .setTimestamp();

                await interaction.reply({ embeds: [tutorialEmbed], ephemeral: true });
                return;
            }

            // üéÆ ADICIONAR JOGO
            if (commandName === 'addjogo') {
                const id = options.getString('id').toLowerCase().replace(/\s+/g, '-');
                const nome = options.getString('nome');
                const emoji = options.getString('emoji');
                const descricao = options.getString('descricao');
                const ativo = options.getBoolean('ativo') !== false; // Padr√£o true
                const ordem = options.getInteger('ordem') || 999;

                const jogos = await obterTodosJogos();

                if (jogos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Jogo j√° existe!**\n\nüÜî **ID:** ${id}\nüéÆ **Nome atual:** ${jogos[id].nome}\n\nüí° **Dica:** Use \`/editjogo\` para modificar ou escolha outro ID.`,
                        ephemeral: true
                    });
                    return;
                }

                jogos[id] = {
                    id: id,
                    nome: nome,
                    emoji: emoji,
                    descricao: descricao,
                    ativo: ativo,
                    ordem: ordem
                };

                const salvou = await salvarJogos(jogos);

                if (salvou) {
                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ JOGO ADICIONADO COM SUCESSO!')
                        .setDescription(`**${emoji} ${nome}** foi adicionado ao sistema!`)
                        .addFields([
                            { name: 'üÜî ID', value: id, inline: true },
                            { name: 'üéÆ Nome', value: nome, inline: true },
                            { name: 'üòÄ Emoji', value: emoji, inline: true },
                            { name: 'üìù Descri√ß√£o', value: descricao, inline: false },
                            { name: 'üü¢ Ativo', value: ativo ? 'Sim' : 'N√£o', inline: true },
                            { name: 'üî¢ Ordem', value: ordem.toString(), inline: true },
                            { name: 'üìä Status', value: 'Dispon√≠vel', inline: true }
                        ])
                        .setColor(0x00FF00)
                        .setFooter({ text: 'Jogo dispon√≠vel! Agora voc√™ pode adicionar servi√ßos para ele.' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.jogosDisponiveis = jogos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao salvar jogo!** Tente novamente mais tarde.',
                        ephemeral: true
                    });
                }
            }

            // üéÆ EDITAR JOGO
            if (commandName === 'editjogo') {
                const id = options.getString('id').toLowerCase();
                const campo = options.getString('campo');
                const valor = options.getString('valor');

                const jogos = await obterTodosJogos();

                if (!jogos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Jogo n√£o encontrado!**\n\nüÜî **ID procurado:** ${id}\n\nüí° **Dica:** Use \`/listjogos\` para ver todos os IDs dispon√≠veis.`,
                        ephemeral: true
                    });
                    return;
                }

                const valorOriginal = jogos[id][campo];

                if (campo === 'ativo') {
                    const novoAtivo = valor.toLowerCase() === 'true';
                    jogos[id][campo] = novoAtivo;
                } else if (campo === 'ordem') {
                    const novaOrdem = parseInt(valor);
                    if (isNaN(novaOrdem)) {
                        await interaction.reply({
                            content: '‚ùå **Ordem inv√°lida!** Informe um n√∫mero inteiro (ex: 5)',
                            ephemeral: true
                        });
                        return;
                    }
                    jogos[id][campo] = novaOrdem;
                } else {
                    jogos[id][campo] = valor;
                }

                const salvou = await salvarJogos(jogos);

                if (salvou) {
                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ JOGO EDITADO COM SUCESSO!')
                        .setDescription(`**${jogos[id].emoji} ${jogos[id].nome}** foi atualizado!`)
                        .addFields([
                            { name: 'üÜî ID', value: id, inline: true },
                            { name: 'üîß Campo Editado', value: campo, inline: true },
                            { name: 'üìä Status', value: 'Atualizado', inline: true },
                            { name: '‚¨ÖÔ∏è Valor Anterior', value: String(valorOriginal), inline: true },
                            { name: '‚û°Ô∏è Novo Valor', value: valor, inline: true },
                            { name: '‚ö° Efeito', value: 'Imediato', inline: true }
                        ])
                        .setColor(0x0099FF)
                        .setFooter({ text: 'Use /recarregarmensagens para atualizar mensagens p√∫blicas!' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.jogosDisponiveis = jogos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao salvar altera√ß√µes!** Tente novamente mais tarde.',
                        ephemeral: true
                    });
                }
            }

            // üéÆ REMOVER JOGO
            if (commandName === 'removejogo') {
                const id = options.getString('id').toLowerCase();
                const jogos = await obterTodosJogos();
                const servicos = await obterTodosServicos();

                if (!jogos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Jogo n√£o encontrado!**\n\nüÜî **ID procurado:** ${id}`,
                        ephemeral: true
                    });
                    return;
                }

                // Conta servi√ßos do jogo
                const servicosDoJogo = Object.values(servicos).filter(s => s.jogo_id === id);
                const jogoInfo = jogos[id];

                // Remove jogo
                delete jogos[id];

                // Remove todos os servi√ßos do jogo
                for (const servico of servicosDoJogo) {
                    delete servicos[servico.id];
                }

                const salvouJogos = await salvarJogos(jogos);
                const salvouServicos = await salvarServicos(servicos);

                if (salvouJogos && salvouServicos) {
                    const embed = new EmbedBuilder()
                        .setTitle('üóëÔ∏è JOGO REMOVIDO!')
                        .setDescription(`**${jogoInfo.emoji} ${jogoInfo.nome}** foi removido do sistema.`)
                        .addFields([
                            { name: 'üÜî ID Removido', value: id, inline: true },
                            { name: 'üõ†Ô∏è Servi√ßos Afetados', value: `${servicosDoJogo.length} removidos`, inline: true },
                            { name: 'üìä Status', value: 'Removido', inline: true }
                        ])
                        .setColor(0xFF0000)
                        .setFooter({ text: 'Jogo e todos os servi√ßos removidos! Use /recarregarmensagens.' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.jogosDisponiveis = jogos;
                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao remover jogo!** Tente novamente.',
                        ephemeral: true
                    });
                }
            }

            // üéÆ LISTAR JOGOS
            if (commandName === 'listjogos') {
                const jogos = await obterTodosJogos();
                const lista = Object.values(jogos).sort((a, b) => (a.ordem || 999) - (b.ordem || 999));

                if (lista.length === 0) {
                    await interaction.reply({
                        content: 'üéÆ **Nenhum jogo encontrado!**',
                        ephemeral: true
                    });
                    return;
                }

                const servicos = await obterTodosServicos();

                const embed = new EmbedBuilder()
                    .setTitle(`üéÆ LISTA DE JOGOS (${lista.length} total)`)
                    .setDescription(
                        lista.map(j => {
                            const servicosCount = Object.values(servicos).filter(s => s.jogo_id === j.id).length;
                            const servicosDestaque = Object.values(servicos).filter(s => s.jogo_id === j.id && s.destaque).length;

                            return `**${j.emoji} ${j.nome}** (\`${j.id}\`)\n` +
                                `${j.ativo ? 'üü¢ **ATIVO**' : 'üî¥ **INATIVO**'} ‚Ä¢ üî¢ Ordem: ${j.ordem || 999}\n` +
                                `üìä ${servicosCount} servi√ßos (${servicosDestaque} em destaque)\n` +
                                `üìù ${j.descricao}\n`;
                        }).join('\n')
                    )
                    .setColor(0x5865F2)
                    .setFooter({ text: `Total: ${lista.length} jogos ‚Ä¢ Use /addjogo para adicionar mais` })
                    .setTimestamp();

                await interaction.reply({ embeds: [embed], ephemeral: true });
            }

            // üõ†Ô∏è ADICIONAR SERVI√áO
            if (commandName === 'addservico') {
                const jogoId = options.getString('jogo').toLowerCase();
                const id = options.getString('id').toLowerCase().replace(/\s+/g, '-');
                const nome = options.getString('nome');
                const descricao = options.getString('descricao');
                const preco = options.getNumber('preco');
                const tempo = options.getString('tempo');
                const emoji = options.getString('emoji');
                const destaque = options.getBoolean('destaque') || false;
                const ordem = options.getInteger('ordem') || 999;

                const jogos = await obterTodosJogos();
                const servicos = await obterTodosServicos();

                if (!jogos[jogoId]) {
                    await interaction.reply({
                        content: `‚ùå **Jogo n√£o encontrado!**\n\nüéÆ **ID procurado:** ${jogoId}\n\nüí° **Dica:** Use \`/listjogos\` para ver os jogos dispon√≠veis.`,
                        ephemeral: true
                    });
                    return;
                }

                if (servicos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Servi√ßo j√° existe!**\n\nüÜî **ID:** ${id}\nüìù **Nome atual:** ${servicos[id].nome}\n\nüí° **Dica:** Use \`/editservico\` para modificar ou escolha outro ID.`,
                        ephemeral: true
                    });
                    return;
                }

                const jogo = jogos[jogoId];
                servicos[id] = {
                    id: id,
                    jogo_id: jogoId,
                    nome: nome,
                    descricao: descricao,
                    preco: preco,
                    tempo: tempo,
                    emoji: emoji,
                    destaque: destaque,
                    ordem: ordem
                };

                const salvou = await salvarServicos(servicos);

                if (salvou) {
                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ SERVI√áO ADICIONADO COM SUCESSO!')
                        .setDescription(`**${emoji} ${nome}** foi adicionado ao **${jogo.emoji} ${jogo.nome}**!`)
                        .addFields([
                            { name: 'üÜî ID', value: id, inline: true },
                            { name: 'üéÆ Jogo', value: `${jogo.emoji} ${jogo.nome}`, inline: true },
                            { name: 'üí∞ Pre√ßo', value: `R$ ${preco.toFixed(2).replace('.', ',')}`, inline: true },
                            { name: '‚è±Ô∏è Tempo', value: tempo, inline: true },
                            { name: '‚≠ê Destaque', value: destaque ? 'Sim' : 'N√£o', inline: true },
                            { name: 'üî¢ Ordem', value: ordem.toString(), inline: true },
                            { name: 'üìù Descri√ß√£o', value: descricao, inline: false }
                        ])
                        .setColor(0x00FF00)
                        .setFooter({ text: 'Servi√ßo dispon√≠vel! Use /recarregarmensagens para atualizar mensagens.' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao salvar servi√ßo!** Tente novamente mais tarde.',
                        ephemeral: true
                    });
                }
            }

            // üõ†Ô∏è EDITAR SERVI√áO
            if (commandName === 'editservico') {
                const id = options.getString('id').toLowerCase();
                const campo = options.getString('campo');
                const valor = options.getString('valor');

                const servicos = await obterTodosServicos();

                if (!servicos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Servi√ßo n√£o encontrado!**\n\nüÜî **ID procurado:** ${id}\n\nüí° **Dica:** Use \`/listservicos\` para ver todos os IDs dispon√≠veis.`,
                        ephemeral: true
                    });
                    return;
                }

                const valorOriginal = servicos[id][campo];

                if (campo === 'preco') {
                    const novoPreco = parseFloat(valor);
                    if (isNaN(novoPreco) || novoPreco <= 0) {
                        await interaction.reply({
                            content: '‚ùå **Pre√ßo inv√°lido!** Informe um valor num√©rico positivo (ex: 25.50)',
                            ephemeral: true
                        });
                        return;
                    }
                    servicos[id][campo] = novoPreco;
                } else if (campo === 'destaque') {
                    const novoDestaque = valor.toLowerCase() === 'true';
                    servicos[id][campo] = novoDestaque;
                } else if (campo === 'ordem') {
                    const novaOrdem = parseInt(valor);
                    if (isNaN(novaOrdem)) {
                        await interaction.reply({
                            content: '‚ùå **Ordem inv√°lida!** Informe um n√∫mero inteiro (ex: 5)',
                            ephemeral: true
                        });
                        return;
                    }
                    servicos[id][campo] = novaOrdem;
                } else if (campo === 'jogo_id') {
                    const jogos = await obterTodosJogos();
                    const novoJogoId = valor.toLowerCase();
                    if (!jogos[novoJogoId]) {
                        await interaction.reply({
                            content: `‚ùå **Jogo n√£o encontrado!** ID: ${novoJogoId}\n\nüí° Use \`/listjogos\` para ver jogos dispon√≠veis.`,
                            ephemeral: true
                        });
                        return;
                    }
                    servicos[id][campo] = novoJogoId;
                } else {
                    servicos[id][campo] = valor;
                }

                const salvou = await salvarServicos(servicos);

                if (salvou) {
                    const jogo = await getJogo(servicos[id].jogo_id);
                    const embed = new EmbedBuilder()
                        .setTitle('‚úÖ SERVI√áO EDITADO COM SUCESSO!')
                        .setDescription(`**${servicos[id].emoji} ${servicos[id].nome}** foi atualizado!`)
                        .addFields([
                            { name: 'üÜî ID', value: id, inline: true },
                            { name: 'üéÆ Jogo', value: jogo ? `${jogo.emoji} ${jogo.nome}` : servicos[id].jogo_id, inline: true },
                            { name: 'üîß Campo Editado', value: campo, inline: true },
                            { name: '‚¨ÖÔ∏è Valor Anterior', value: String(valorOriginal), inline: true },
                            { name: '‚û°Ô∏è Novo Valor', value: valor, inline: true },
                            { name: '‚ö° Efeito', value: 'Imediato', inline: true }
                        ])
                        .setColor(0x0099FF)
                        .setFooter({ text: 'Use /recarregarmensagens para atualizar mensagens p√∫blicas!' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao salvar altera√ß√µes!** Tente novamente mais tarde.',
                        ephemeral: true
                    });
                }
            }

            // üõ†Ô∏è REMOVER SERVI√áO
            if (commandName === 'removeservico') {
                const id = options.getString('id').toLowerCase();
                const servicos = await obterTodosServicos();

                if (!servicos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Servi√ßo n√£o encontrado!**\n\nüÜî **ID procurado:** ${id}`,
                        ephemeral: true
                    });
                    return;
                }

                const servicoInfo = servicos[id];
                const jogo = await getJogo(servicoInfo.jogo_id);
                delete servicos[id];

                const salvou = await salvarServicos(servicos);

                if (salvou) {
                    const embed = new EmbedBuilder()
                        .setTitle('üóëÔ∏è SERVI√áO REMOVIDO!')
                        .setDescription(`**${servicoInfo.emoji} ${servicoInfo.nome}** foi removido do sistema.`)
                        .addFields([
                            { name: 'üÜî ID Removido', value: id, inline: true },
                            { name: 'üéÆ Jogo', value: jogo ? `${jogo.emoji} ${jogo.nome}` : servicoInfo.jogo_id, inline: true },
                            { name: 'üí∞ Pre√ßo Era', value: `R$ ${servicoInfo.preco.toFixed(2).replace('.', ',')}`, inline: true }
                        ])
                        .setColor(0xFF0000)
                        .setFooter({ text: 'Servi√ßo removido! Use /recarregarmensagens para atualizar.' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao remover servi√ßo!** Tente novamente.',
                        ephemeral: true
                    });
                }
            }

            // üõ†Ô∏è LISTAR SERVI√áOS
            if (commandName === 'listservicos') {
                const jogoFiltro = options.getString('jogo')?.toLowerCase();
                const filtroTipo = options.getString('filtro') || 'todos';

                const servicos = await obterTodosServicos();
                const jogos = await obterTodosJogos();

                let lista = Object.values(servicos);

                // Filtro por jogo
                if (jogoFiltro) {
                    lista = lista.filter(s => s.jogo_id === jogoFiltro);
                }

                // Filtro por tipo
                if (filtroTipo === 'destaque') {
                    lista = lista.filter(s => s.destaque === true);
                } else if (filtroTipo === 'padrao') {
                    lista = lista.filter(s => s.destaque === false);
                }

                lista.sort((a, b) => (a.ordem || 999) - (b.ordem || 999));

                if (lista.length === 0) {
                    await interaction.reply({
                        content: 'üìã **Nenhum servi√ßo encontrado com os filtros aplicados!**',
                        ephemeral: true
                    });
                    return;
                }

                // Agrupa por jogo
                const servicosPorJogo = {};
                for (const servico of lista) {
                    if (!servicosPorJogo[servico.jogo_id]) {
                        servicosPorJogo[servico.jogo_id] = [];
                    }
                    servicosPorJogo[servico.jogo_id].push(servico);
                }

                let descricao = '';
                for (const [jogoId, servicosDoJogo] of Object.entries(servicosPorJogo)) {
                    const jogo = jogos[jogoId];
                    descricao += `**${jogo ? jogo.emoji + ' ' + jogo.nome : jogoId}:**\n`;

                    descricao += servicosDoJogo.map(s => 
                        `${s.emoji} **${s.nome}** (\`${s.id}\`)\n` +
                        `üí∞ R$ ${s.preco.toFixed(2).replace('.', ',')} ‚Ä¢ ‚è±Ô∏è ${s.tempo}\n` +
                        `${s.destaque ? '‚≠ê **EM DESTAQUE**' : 'üî∏ Padr√£o'} ‚Ä¢ üî¢ Ordem: ${s.ordem || 999}\n`
                    ).join('\n') + '\n\n';
                }

                const embed = new EmbedBuilder()
                    .setTitle(`üìã LISTA DE SERVI√áOS (${lista.length} encontrados)`)
                    .setDescription(descricao)
                    .setColor(0x5865F2)
                    .setFooter({ 
                        text: `Filtros: ${jogoFiltro ? 'Jogo: ' + jogoFiltro : 'Todos os jogos'} ‚Ä¢ ${filtroTipo} ‚Ä¢ Total: ${lista.length}`,
                    })
                    .setTimestamp();

                await interaction.reply({ embeds: [embed], ephemeral: true });
            }

            // üí∞ PRE√áO SERVI√áO
            if (commandName === 'precoservico') {
                const id = options.getString('id').toLowerCase();
                const novoPreco = options.getNumber('preco');

                const servicos = await obterTodosServicos();

                if (!servicos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Servi√ßo n√£o encontrado!**\n\nüÜî **ID:** ${id}`,
                        ephemeral: true
                    });
                    return;
                }

                if (novoPreco <= 0) {
                    await interaction.reply({
                        content: '‚ùå **Pre√ßo inv√°lido!** O valor deve ser maior que zero.',
                        ephemeral: true
                    });
                    return;
                }

                const precoAntigo = servicos[id].preco;
                servicos[id].preco = novoPreco;

                const salvou = await salvarServicos(servicos);

                if (salvou) {
                    const jogo = await getJogo(servicos[id].jogo_id);
                    const embed = new EmbedBuilder()
                        .setTitle('üí∞ PRE√áO ATUALIZADO!')
                        .setDescription(`**${servicos[id].emoji} ${servicos[id].nome}**`)
                        .addFields([
                            { name: 'üéÆ Jogo', value: jogo ? `${jogo.emoji} ${jogo.nome}` : servicos[id].jogo_id, inline: true },
                            { name: '‚¨ÖÔ∏è Pre√ßo Anterior', value: `R$ ${precoAntigo.toFixed(2).replace('.', ',')}`, inline: true },
                            { name: '‚û°Ô∏è Novo Pre√ßo', value: `R$ ${novoPreco.toFixed(2).replace('.', ',')}`, inline: true },
                            { name: 'üìà Varia√ß√£o', value: `${novoPreco > precoAntigo ? '+' : ''}${((novoPreco - precoAntigo) / precoAntigo * 100).toFixed(1)}%`, inline: true }
                        ])
                        .setColor(novoPreco > precoAntigo ? 0xFF0000 : 0x00FF00)
                        .setFooter({ text: 'Pre√ßo atualizado! Use /recarregarmensagens para atualizar mensagens.' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao atualizar pre√ßo!** Tente novamente.',
                        ephemeral: true
                    });
                }
            }

            // ‚≠ê DESTACAR SERVI√áO
            if (commandName === 'destacarservico') {
                const id = options.getString('id').toLowerCase();
                const destaque = options.getBoolean('destaque');

                const servicos = await obterTodosServicos();

                if (!servicos[id]) {
                    await interaction.reply({
                        content: `‚ùå **Servi√ßo n√£o encontrado!**\n\nüÜî **ID:** ${id}`,
                        ephemeral: true
                    });
                    return;
                }

                const statusAnterior = servicos[id].destaque;
                servicos[id].destaque = destaque;

                const salvou = await salvarServicos(servicos);

                if (salvou) {
                    const jogo = await getJogo(servicos[id].jogo_id);
                    const embed = new EmbedBuilder()
                        .setTitle(destaque ? '‚≠ê SERVI√áO EM DESTAQUE!' : 'üî∏ SERVI√áO REMOVIDO DO DESTAQUE')
                        .setDescription(`**${servicos[id].emoji} ${servicos[id].nome}**`)
                        .addFields([
                            { name: 'üÜî ID', value: id, inline: true },
                            { name: 'üéÆ Jogo', value: jogo ? `${jogo.emoji} ${jogo.nome}` : servicos[id].jogo_id, inline: true },
                            { name: '‚¨ÖÔ∏è Status Anterior', value: statusAnterior ? 'Em Destaque' : 'Padr√£o', inline: true },
                            { name: '‚û°Ô∏è Novo Status', value: destaque ? 'Em Destaque' : 'Padr√£o', inline: true },
                            { name: 'üìä Efeito', value: destaque ? 'Aparecer√° em PRINCIPAIS SERVI√áOS' : 'Removido da mensagem principal', inline: false }
                        ])
                        .setColor(destaque ? 0xFFD700 : 0x808080)
                        .setFooter({ text: 'Use /recarregarmensagens para aplicar mudan√ßas nas mensagens!' })
                        .setTimestamp();

                    await interaction.reply({ embeds: [embed], ephemeral: true });

                    global.servicosCompletos = servicos;
                } else {
                    await interaction.reply({
                        content: '‚ùå **Erro ao atualizar destaque!** Tente novamente.',
                        ephemeral: true
                    });
                }
            }

            // üìä ESTAT√çSTICAS
            if (commandName === 'estatisticas') {
                const jogos = await obterTodosJogos();
                const servicos = await obterTodosServicos();

                const jogosAtivos = await obterJogosAtivos();
                const totalServicos = Object.keys(servicos).length;
                const servicosDestaque = Object.values(servicos).filter(s => s.destaque).length;

                // Estat√≠sticas por jogo
                const statsPorJogo = {};
                for (const jogo of Object.values(jogos)) {
                    const servicosDoJogo = Object.values(servicos).filter(s => s.jogo_id === jogo.id);
                    const servicosDestaqueDoJogo = servicosDoJogo.filter(s => s.destaque);

                    statsPorJogo[jogo.id] = {
                        nome: jogo.nome,
                        emoji: jogo.emoji,
                        ativo: jogo.ativo,
                        totalServicos: servicosDoJogo.length,
                        servicosDestaque: servicosDestaqueDoJogo.length,
                        precoMedio: servicosDoJogo.length > 0 ? 
                            (servicosDoJogo.reduce((sum, s) => sum + s.preco, 0) / servicosDoJogo.length) : 0
                    };
                }

                const embed = new EmbedBuilder()
                    .setTitle('üìä ESTAT√çSTICAS DO SISTEMA MULTI-JOGOS')
                    .addFields([
                        {
                            name: 'üéÆ **RESUMO GERAL**',
                            value: 
                                `**Jogos:** ${Object.keys(jogos).length} total (${jogosAtivos.length} ativos)\n` +
                                `**Servi√ßos:** ${totalServicos} total (${servicosDestaque} em destaque)\n` +
                                `**Threads ativas:** ${threadsAtivas.size}\n` +
                                `**Threads finalizadas:** ${threadsFinalizadas.size}`,
                            inline: false
                        },
                        {
                            name: 'üéØ **ESTAT√çSTICAS POR JOGO**',
                            value: Object.values(statsPorJogo).map(stat => 
                                `**${stat.emoji} ${stat.nome}** ${stat.ativo ? 'üü¢' : 'üî¥'}\n` +
                                `üìä ${stat.totalServicos} servi√ßos (${stat.servicosDestaque} destaque)\n` +
                                `üí∞ Pre√ßo m√©dio: R$ ${stat.precoMedio.toFixed(2).replace('.', ',')}`
                            ).join('\n\n'),
                            inline: false
                        },
                        {
                            name: 'üíæ **SISTEMA**',
                            value: 
                                `**Carrinhos ativos:** ${carrinhos.size}\n` +
                                `**Mensagens oficiais:** ${mensagensOficiais.size}\n` +
                                `**Uptime:** ${Math.floor(client.uptime / 60000)} minutos\n` +
                                `**Vers√£o:** Multi-Jogos v2.2`,
                            inline: false
                        }
                    ])
                    .setColor(0x00D4AA)
                    .setFooter({ 
                        text: `Sistema Multi-Jogos ‚Ä¢ Atualizado em ${new Date().toLocaleString('pt-BR')}`,
                        iconURL: interaction.guild.iconURL()
                    })
                    .setTimestamp();

                await interaction.reply({ embeds: [embed], ephemeral: true });
            }

            // üîÑ RECARREGAR MENSAGENS
            if (commandName === 'recarregarmensagens') {
                await interaction.reply({
                    content: 'üîÑ **Recarregando mensagens multi-jogos com servi√ßos atualizados...**',
                    ephemeral: true
                });

                try {
                    await postarServicosAutomatico(interaction.guild);

                    const jogosAtivos = await obterJogosAtivos();
                    const totalServicos = Object.keys(global.servicosCompletos).length;

                    await interaction.followUp({
                        content: `‚úÖ **Mensagens recarregadas com sucesso!**\n\nüìä **Estat√≠sticas atualizadas:**\nüéÆ ${jogosAtivos.length} jogos ativos\nüõ†Ô∏è ${totalServicos} servi√ßos dispon√≠veis\n‚≠ê Destaques organizados por jogo`,
                        ephemeral: true
                    });
                } catch (error) {
                    console.error('‚ùå Erro ao recarregar mensagens multi-jogos:', error);
                    await interaction.followUp({
                        content: '‚ùå **Erro ao recarregar mensagens!** Verifique os logs.',
                        ephemeral: true
                    });
                }
            }

        } catch (error) {
            console.error(`‚ùå Erro no comando ${commandName}:`, error);
            await interaction.reply({
                content: `‚ùå **Erro interno!** Contate o desenvolvedor.\n\`\`\`${error.message}\`\`\``,
                ephemeral: true
            });
        }
        return;
    }

    // ================================================
    // üõí INTERA√á√ïES DO CARRINHO MULTI-JOGOS
    // ================================================
    if (!interaction.isStringSelectMenu() && !interaction.isButton()) return;

    const userId = interaction.user.id;
    const user = interaction.user;
    const member = interaction.member;
    const thread = interaction.channel;
    const threadId = thread?.id;

    try {
        if (!member) {
            console.error(`‚ùå Member n√£o encontrado para ${user.tag}`);
            return;
        }

        if (isThreadFinalizada(threadId) && !isQualquerAdmin(member)) {
            await interaction.reply({
                content: 'üîí **Thread Finalizada pela Administra√ß√£o**\n\nEsta thread foi finalizada por um administrador Hellza. Apenas a equipe administrativa pode interagir aqui.\n\n‚úÖ **Para novos servi√ßos:** Volte ao canal p√∫blico e reaja üõí na mensagem fixada oficial.',
                flags: [4096]
            });
            return;
        }

        // üéÆ SELE√á√ÉO DE JOGO (PRIMEIRO DROPDOWN)
        if (interaction.customId === 'select_jogo') {
            const jogoId = interaction.values[0];
            const jogo = await getJogo(jogoId);

            if (!jogo) {
                await interaction.reply({ 
                    content: 'Jogo n√£o encontrado.', 
                    flags: [4096]
                });
                return;
            }

            // Seleciona o jogo no carrinho
            selecionarJogo(userId, jogoId);

            // Cria dropdown de servi√ßos para o jogo selecionado
            const dropdownServicos = await criarDropdownServicos(jogoId);

            if (!dropdownServicos) {
                await interaction.reply({
                    content: `‚ùå **${jogo.emoji} ${jogo.nome}** n√£o possui servi√ßos dispon√≠veis ainda.\n\nüí° **Dica:** Escolha outro jogo ou aguarde novos servi√ßos serem adicionados.`,
                    flags: [4096]
                });
                return;
            }

            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);
            const buttonsCarrinho = criarBotoesCarrinho();

            await interaction.update({
                embeds: [carrinhoEmbed],
                components: [dropdownServicos, buttonsCarrinho]
            });

            await interaction.followUp({
                content: `üéÆ **${jogo.emoji} ${jogo.nome}** selecionado! Agora escolha os servi√ßos que deseja.`,
                flags: [4096]
            });
        }

        // üõ†Ô∏è SELE√á√ÉO DE SERVI√áO (SEGUNDO DROPDOWN)
        if (interaction.customId === 'select_servico') {
            const servicoId = interaction.values[0];
            const servico = await getServico(servicoId);

            if (!servico) {
                await interaction.reply({ 
                    content: 'Servi√ßo n√£o encontrado.', 
                    flags: [4096]
                });
                return;
            }

            const carrinho = getCarrinho(userId);
            const itemExistente = carrinho.items.find(item => item.id === servicoId);

            if (itemExistente) {
                await interaction.reply({
                    content: `üì¶ **${servico.nome}** j√° est√° no seu carrinho. Escolha a nova quantidade:`,
                    components: [criarDropdownQuantidade(servicoId)],
                    flags: [4096]
                });
            } else {
                await adicionarItem(userId, servicoId, 1);
                const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);
                const dropdownServicos = await criarDropdownServicos(servico.jogo_id);
                const buttonsCarrinho = criarBotoesCarrinho();

                await interaction.update({
                    embeds: [carrinhoEmbed],
                    components: [dropdownServicos, buttonsCarrinho]
                });

                await interaction.followUp({
                    content: `‚úÖ **${servico.nome}** adicionado ao carrinho. Deseja adicionar mais unidades?`,
                    components: [criarDropdownQuantidade(servicoId)],
                    flags: [4096]
                });
            }
        }

        // üì¶ SELE√á√ÉO DE QUANTIDADE (TERCEIRO DROPDOWN)
        if (interaction.customId === 'select_quantidade') {
            const [servicoId, quantidadeStr] = interaction.values[0].split('_');
            const quantidade = parseInt(quantidadeStr);
            const servico = await getServico(servicoId);

            if (!servico) {
                await interaction.reply({ 
                    content: 'Servi√ßo n√£o encontrado.', 
                    flags: [4096]
                });
                return;
            }

            removerItem(userId, servicoId);
            await adicionarItem(userId, servicoId, quantidade);

            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);
            const dropdownServicos = await criarDropdownServicos(servico.jogo_id);
            const buttonsCarrinho = criarBotoesCarrinho();

            await interaction.update({
                embeds: [carrinhoEmbed],
                components: [dropdownServicos, buttonsCarrinho]
            });

            await interaction.followUp({ 
                content: `üì¶ Quantidade de **${servico.nome}** atualizada para **${quantidade}x**.`, 
                flags: [4096]
            });
        }

        // üîÑ ATUALIZAR CARRINHO
        if (interaction.customId === 'atualizar_carrinho') {
            const carrinho = getCarrinho(userId);
            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);

            if (carrinho.jogoSelecionado) {
                const dropdownServicos = await criarDropdownServicos(carrinho.jogoSelecionado);
                const buttonsCarrinho = criarBotoesCarrinho();

                await interaction.update({
                    embeds: [carrinhoEmbed],
                    components: [dropdownServicos, buttonsCarrinho]
                });
            } else {
                const dropdownJogos = await criarDropdownJogos();
                const buttonsCarrinho = criarBotoesCarrinho();

                await interaction.update({
                    embeds: [carrinhoEmbed],
                    components: [dropdownJogos, buttonsCarrinho]
                });
            }
        }

        // üéÆ TROCAR JOGO
        if (interaction.customId === 'trocar_jogo') {
            limparCarrinho(userId); // Limpa tudo ao trocar jogo
            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);
            const dropdownJogos = await criarDropdownJogos();
            const buttonsCarrinho = criarBotoesCarrinho();

            await interaction.update({
                embeds: [carrinhoEmbed],
                components: [dropdownJogos, buttonsCarrinho]
            });

            await interaction.followUp({
                content: 'üéÆ **Jogo alterado!** Seu carrinho foi limpo. Selecione um novo jogo para come√ßar.',
                flags: [4096]
            });
        }

        // ‚ûñ REMOVER ITEM
        if (interaction.customId === 'remover_item') {
            const carrinho = getCarrinho(userId);
            if (carrinho.items.length === 0) {
                await interaction.reply({ 
                    content: 'Seu carrinho j√° est√° vazio!', 
                    flags: [4096]
                });
                return;
            }

            const dropdownRemover = criarDropdownRemover(userId);
            await interaction.reply({
                content: 'üóëÔ∏è Escolha qual item deseja remover:',
                components: [dropdownRemover],
                flags: [4096]
            });
        }

        // ‚úÖ CONFIRMAR REMO√á√ÉO
        if (interaction.customId === 'confirmar_remocao') {
            const servicoId = interaction.values[0];
            const servico = await getServico(servicoId);
            removerItem(userId, servicoId);

            const carrinho = getCarrinho(userId);
            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);

            let componentes = [];
            if (carrinho.jogoSelecionado) {
                const dropdownServicos = await criarDropdownServicos(carrinho.jogoSelecionado);
                componentes.push(dropdownServicos);
            } else {
                const dropdownJogos = await criarDropdownJogos();
                componentes.push(dropdownJogos);
            }
            componentes.push(criarBotoesCarrinho());

            await interaction.update({
                embeds: [carrinhoEmbed],
                components: componentes
            });

            const nomeServico = servico ? servico.nome : 'Servi√ßo removido';
            await interaction.followUp({ 
                content: `üóëÔ∏è **${nomeServico}** removido do carrinho.`, 
                flags: [4096]
            });
        }

        // üßπ LIMPAR CARRINHO
        if (interaction.customId === 'limpar_carrinho') {
            limparCarrinho(userId);

            const carrinhoEmbed = await criarCarrinhoEmbed(userId, user);
            const dropdownJogos = await criarDropdownJogos();
            const buttonsCarrinho = criarBotoesCarrinho();

            await interaction.update({
                embeds: [carrinhoEmbed],
                components: [dropdownJogos, buttonsCarrinho]
            });

            await interaction.followUp({ 
                content: 'üßπ Seu carrinho foi limpo! Selecione um jogo para come√ßar novamente.', 
                flags: [4096]
            });
        }

        // üí≥ FINALIZAR PEDIDO
        if (interaction.customId === 'finalizar_pedido') {
            const carrinho = getCarrinho(userId);
            if (carrinho.items.length === 0) {
                await interaction.reply({ 
                    content: 'Seu carrinho est√° vazio. Adicione itens antes de finalizar!', 
                    flags: [4096]
                });
                return;
            }

            const pagamentoEmbed = await criarPagamentoEmbed(userId, user);
            const adminButton = criarBotaoAdminFinalizar(threadId);

            await interaction.update({
                embeds: [pagamentoEmbed],
                components: [adminButton]
            });

            const clienteMember = interaction.member;
            const cargoEmAndamento = interaction.guild.roles.cache.find(role => role.name === CARGO_SERVICO_EM_ANDAMENTO);
            if (cargoEmAndamento && clienteMember) {
                if (!clienteMember.roles.cache.has(cargoEmAndamento.id)) {
                    try {
                        await clienteMember.roles.add(cargoEmAndamento);
                        console.log(`[Cargo] Adicionado '${CARGO_SERVICO_EM_ANDAMENTO}' para ${clienteMember.user.tag}`);
                    } catch (error) {
                        console.error(`‚ùå Erro ao adicionar cargo:`, error.message);
                    }
                }
            }

            // Resumo dos jogos no pedido
            const jogosPedido = [...new Set(carrinho.items.map(item => item.jogo_id))];
            const resumoJogos = [];
            for (const jogoId of jogosPedido) {
                const jogo = await getJogo(jogoId);
                resumoJogos.push(jogo ? `${jogo.emoji} ${jogo.nome}` : jogoId);
            }

            await thread.send(`‚úÖ ${user}, seu pedido multi-jogos foi finalizado! A equipe Hellza j√° foi notificada e aguarda seu comprovante de PIX.\n\nüéÆ **Jogos no pedido:** ${resumoJogos.join(', ')}\n\nüö® **IMPORTANTE:** O bot√£o vermelho acima √© **exclusivo para administradores**. Apenas admins podem finalizar o servi√ßo.\n\nüí¨ **Agora voc√™ pode:** Enviar seu comprovante PIX, tirar d√∫vidas, ou conversar normalmente aqui na thread!`);

            const adminChannel = interaction.guild.channels.cache.find(c => c.name.toLowerCase().includes('logs') || c.name.toLowerCase().includes('admin'));
            if (adminChannel && adminChannel.isTextBased()) {
                await adminChannel.send(`üîî **NOVO PEDIDO MULTI-JOGOS!** O usu√°rio ${user} (ID: ${userId}) finalizou um pedido na thread ${thread.name} (${thread.url}).\nüéÆ **Jogos:** ${resumoJogos.join(', ')}`);
            }
        }

        // üëë BOT√ÉO ADMIN FINALIZAR (mesmo sistema de seguran√ßa)
        if (interaction.customId.startsWith('admin_finalizar_')) {
            console.log(`üîç Tentativa de finaliza√ß√£o multi-jogos: ${user.tag} (${userId}) na guild ${interaction.guild?.name}`);

            if (!member) {
                console.log(`üö´ FALHA 1: Member inexistente para ${user.tag}`);
                await interaction.reply({ 
                    content: '‚ùå **Erro de Autentica√ß√£o**\nMembro n√£o encontrado no servidor.', 
                    flags: [4096]
                });
                return;
            }

            const isAdmin = isAdminNaGuild(userId, interaction.guild);
            if (!isAdmin) {
                console.log(`üö´ FALHA 2: ${user.tag} n√£o √© admin na guild ${interaction.guild?.name}`);
                await interaction.reply({ 
                    content: 'üö´ **ACESSO NEGADO!**\n\n‚ùå Voc√™ n√£o tem permiss√£o para finalizar servi√ßos.\n\nüëë **Cargos autorizados:** Hellza, Admin, Moderador, Staff, Suporte.\n\n‚ö†Ô∏è **Tentativa de acesso n√£o autorizada registrada.**', 
                    flags: [4096]
                });
                return;
            }

            const adminConfirmado = isQualquerAdmin(member);
            if (!adminConfirmado) {
                console.log(`üö´ FALHA 3: Valida√ß√£o final falhou para ${user.tag}`);
                await interaction.reply({ 
                    content: 'üö´ **VALIDA√á√ÉO FINAL FALHOU**\n\nVerifique seus cargos com um administrador superior.', 
                    flags: [4096]
                });
                return;
            }

            console.log(`‚úÖ VALIDA√á√ÉO COMPLETA: Admin ${user.tag} autorizado a finalizar servi√ßo multi-jogos`);

            await interaction.update({
                content: `‚úÖ **üéâ SERVI√áO MULTI-JOGOS FINALIZADO COM SUCESSO! üéâ**\n\nüëë **Finalizado por:** ${member.displayName}\nüìÖ **Data:** ${new Date().toLocaleString('pt-BR')}\n\nüíº O cliente foi removido da thread e j√° pode criar uma nova loja quando necess√°rio.\n\nüîí Esta thread ser√° arquivada automaticamente.`,
                embeds: [],
                components: []
            });

            try {
                const clienteMember = thread.guild.members.cache.find(m => 
                    thread.members.cache.has(m.id) && 
                    !m.user.bot && 
                    !isQualquerAdmin(m)
                );

                if (clienteMember) {
                    console.log(`üë§ Cliente identificado: ${clienteMember.user.tag}`);

                    const carrinhoCliente = getCarrinho(clienteMember.id);
                    await logarServicoFinalizado(interaction.guild, clienteMember, member, thread.name, carrinhoCliente);

                    const cargoComprador = thread.guild.roles.cache.find(role => role.name === CARGO_CLIENTE_COMPROU);
                    const cargoEmAndamento = thread.guild.roles.cache.find(role => role.name === CARGO_SERVICO_EM_ANDAMENTO);

                    if (cargoComprador && !clienteMember.roles.cache.has(cargoComprador.id)) {
                        await clienteMember.roles.add(cargoComprador);
                        console.log(`[Cargo] Adicionado '${CARGO_CLIENTE_COMPROU}' para ${clienteMember.user.tag}`);
                    }

                    if (cargoEmAndamento && clienteMember.roles.cache.has(cargoEmAndamento.id)) {
                        await clienteMember.roles.remove(cargoEmAndamento);
                        console.log(`[Cargo] Removido '${CARGO_SERVICO_EM_ANDAMENTO}' de ${clienteMember.user.tag}`);
                    }

                    await thread.members.remove(clienteMember.id);
                    console.log(`üë§ Cliente ${clienteMember.user.tag} removido da thread multi-jogos ${thread.name}`);

                    removerThreadAtiva(clienteMember.id);
                    limparCarrinho(clienteMember.id);

                    try {
                        await clienteMember.send(
                            `üéâ **SERVI√áO MULTI-JOGOS FINALIZADO COM SUCESSO!**\n\n` +
                            `üëë **Finalizado por:** ${member.displayName}\n` +
                            `üìÖ **Data:** ${new Date().toLocaleString('pt-BR')}\n\n` +
                            `‚úÖ Voc√™ recebeu o cargo '${CARGO_CLIENTE_COMPROU}'.\n\n` +
                            `üõí **Para futuros servi√ßos:** Reaja üõí na mensagem fixada oficial nos canais para criar uma nova loja privada!\n\n` +
                            `üôè **Obrigado por escolher a Hellza Gaming!**`
                        );
                    } catch (dmError) {
                        console.error(`‚ùå N√£o foi poss√≠vel enviar DM para ${clienteMember.user.tag}:`, dmError.message);
                    }
                } else {
                    console.log('‚ö†Ô∏è Cliente n√£o encontrado na thread');
                }

                finalizarThread(threadId, member.id);

                const oldName = thread.name;
                const newName = oldName.includes('finalizado') ? oldName : `‚úÖ-finalizado-${oldName.replace('üõí-loja-', '')}`;

                await thread.setName(newName);
                await thread.setArchived(true);

                console.log(`‚úÖ Thread multi-jogos finalizada por ${member.user.tag}: ${oldName} ‚Üí ${newName}`);

                const adminChannel = interaction.guild.channels.cache.find(c => 
                    (c.name.toLowerCase().includes('logs') || c.name.toLowerCase().includes('admin')) &&
                    !c.name.toLowerCase().includes('finalizados')
                );
                if (adminChannel && adminChannel.isTextBased()) {
                    const clienteTag = clienteMember?.user.tag || 'Cliente n√£o encontrado';
                    await adminChannel.send(
                        `üéâ **SERVI√áO MULTI-JOGOS FINALIZADO COM SUCESSO!**\n\n` +
                        `üëë **Admin:** ${member.user.tag}\n` +
                        `üë§ **Cliente:** ${clienteTag}\n` +
                        `üìÑ **Thread:** ${newName}\n` +
                        `üïê **Hor√°rio:** ${new Date().toLocaleString('pt-BR')}\n\n` +
                        `üíº **Status:** Finalizado e arquivado automaticamente\n` +
                        `üìä **Log detalhado enviado para:** #${CANAL_LOG_FINALIZADOS}`
                    );
                }

            } catch (error) {
                console.error(`‚ùå Erro durante finaliza√ß√£o multi-jogos por ${member.user.tag}:`, error.message);

                try {
                    await thread.send(`‚ùå **Erro durante finaliza√ß√£o:** ${error.message}\n\n‚ö†Ô∏è Contate um administrador se o problema persistir.`);
                } catch (sendError) {
                    console.error(`‚ùå N√£o foi poss√≠vel enviar erro na thread:`, sendError.message);
                }
            }
        }

    } catch (error) {
        console.error(`‚ùå Erro na intera√ß√£o multi-jogos ${interaction.customId} por ${user.tag}:`, error);
        try {
            if (interaction.deferred || interaction.replied) {
                await interaction.followUp({ 
                    content: '‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.', 
                    flags: [4096]
                });
            } else {
                await interaction.reply({ 
                    content: '‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.', 
                    flags: [4096]
                });
            }
        } catch (replyError) {
            console.error(`‚ùå Erro ao responder intera√ß√£o:`, replyError.message);
        }
    }
});

// ================================================
// üö´ EVENT: ERROS
// ================================================

client.on(Events.Error, (error) => {
    console.error('‚ùå Erro cr√≠tico no sistema multi-jogos:', error);
});

// ================================================
// üîë LOGIN DO BOT
// ================================================

client.login(process.env.DISCORD_TOKEN);